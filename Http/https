加密

发送方：（content）经过密码secretkey ==>(wewrwrfsfsvx)
接收方： (wewrwrfsfsvx)经过密码secretkey ===>(content)
这种就是对称加密，加密和解密都是同一个密码来操作，需要保证密码的安全，一旦泄露，后果严重
对称加密总结：使用同一秘钥进行加密和解密，难以破解，加密速度快，但是存在秘钥配送问题。

另外一种加密方式：使用两个秘钥，一个用来加密，另一个用来解密，使用共钥加密过的内容，只能通过私钥进行解密。私钥自己有，公钥给别人
A给B发消息，A的私钥保密，A的公钥给B，B的私钥保密，B的公钥给A
A用B的公钥加密，B收到加密信息，用自己私钥解密
典型的非加密算法就是RSA算法，而非对称加密算法也有弊端，无法确定通信双方的身份，会遭到中间人攻击，比如中间人拦截A发送方发出的公钥，然后中间人冒充A的身份
给B接收方发送自己的公钥，而不知情的接收方B就会用中间人的公钥加密数据发给中间人，中间人用自己的私钥进行解密窃取信息。

因此需要解决认证发送方身份的问题，因此引出数字签名问题：
刚才说非对称加密算法，把公钥公开用于他人对数据加密然后发给你，只有你手上的私钥才能将密文解密，其实私钥也可以用来加密数据的，对于RSA算法，私钥加密的数据
只有公钥才能解开。
数字签名是利用了非对称加密的特性，仍然公布公钥，然后用私钥加密数据，然后把加密的数据公布出去，这就是数字签名
数字签名不是保证数据的机密性，而是证实你的身份，证明你的数据确实你本人发送的，
你的私钥加密过的数据，只有你的公钥才能解密，如果有一份加密数据由你的公钥可以解开，这样就证明发送方是你了。
数字签名一定程度上可以认证数据的来源，一定程度上是因为这种方式依然可以受到中间人的攻击，一旦涉及到公钥的发布，可能由中间人发布假的公钥，
因此针对上述问题，必须有一个信任的源头，因此公钥证书应运而生。

证书其实是公钥+签名， 由第三方认证机构颁发，引入可信任的第三方，是终结信任循环的一种可行方案，
证书认证的流程：

A去信任机构认证本人真实身份，并提供自己的公钥，
B想跟A通信，必须先向认证机构获取A的公钥，认证机构会把证书（A的公钥及机构对A公钥的签名）发给B，
B检查签名，确认该公钥是这家认证机构发送的，中途未被篡改，
B通过公钥加密数据，和A进行通信。

实际证书只需安装一次，并不需要每次向认证机构请求，一般是服务器直接给客户端发送证书，而不是认证机构，
我们安装正规的浏览器已经预装了正规机构的认证证书（包含认证机构的公钥），用于确认机构的身份，

大多数网站都使用HTTPS，也就是在HTTP协议




 
