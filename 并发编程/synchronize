内置锁是JVM提供的最便捷的线程同步工具，在代码块或者方法声明上添加synchronized关键字即可使用。
内置锁在Java中被抽象称为监视器锁，在JDK1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量。同步成本很高：1 系统调用引起的内核态与用户态的切换； 
 2 线程阻塞造成的线程之间的切换。因此被称为重量级锁。
 
1 自旋锁
 同步成本很高的内核态与用户态的切换不容易优化，但是我们可以减少线程阻塞造成的线程切换（包括线程挂起和恢复）
 通常用在锁持有时间长 ，但竞争不激烈的场景中，通过自旋的方式竞争锁，不直接阻塞自己，减少了一次线程切换
 但是如果锁的竞争时间长，往往通过自旋的方式获取不到锁，但是白白占用CPU时间，因此这种不建议用
 -XX：-UseSpinning参数关闭自旋锁优化； -XX:PreBlockSpin参数修改默认的自旋次数
 自适应自旋锁：自旋时间不再固定，由前一次同一个锁上的自旋时间及锁的拥有者的状态来决定
 
 2 轻量级锁
 自旋锁目标是降低线程切换的成本，如果没有实际的锁竞争，重量级锁是浪费的，因此轻量级锁的目标是减少无实际竞争情况下，使用重量级锁产生的性能消耗。
 轻量级锁不需要申请互斥量，仅仅将mark word中的部分字节通过CAS方式更新线程栈中的LOCK RECORD.如果更新成功，则轻量级获取成功，记录锁状态标记为轻量级锁
 否则说明已有其他线程获取了轻量级锁，发生了锁竞争，接下来膨胀为重量级锁。
 
 3 偏向锁
 在实际没有竞争且自始至终使用锁的线程都只有一个，维护轻量级锁也是浪费的。偏向锁目标是减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗
 轻量级锁每次申请，释放锁至少一次CAS,偏向锁只有初始化需要一次CAS.
 
