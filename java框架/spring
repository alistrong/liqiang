spring
问题1 IOC inversion of control
what?
对象的实例化权限反转给容器，平常我们一般自己new，即由应用程序控制，所谓反转是将权限反转给容器，而应用程序只需提供对象的类型即可。
why?
1 对象的实例化不是一个简单的事，如对象关系很复杂，依赖关系需要程序员维护，非常头疼
2 解耦，由容器维护具体的对象
3 托管类的产生过程，需要在类的产生过程中做一些处理，比如代理。

问题2 AOP



问题3 循环依赖--属性自动注入
上述问题会涉及到spring bean的生命周期及bean实例化的大概过程

什么是循环依赖
Class A{
  @Autowired
  private B b;
}

Class B{
  @Autowired
  private A a;
}

//初始化spring容器
AnnotiationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
//获取对象实例
ac.getBean(A.class);

spring 单例模式下默认支持循环依赖，
在类A中如何把B类注入进来的？依赖注入是什么时候完成的？
单例情况下，是在初始化spring容器时完成依赖注入
原形情况下，是在getBean时完成依赖注入

在初始化spring容器过程中做了很多事情，其中包括bean实例初始化，而在bean实例初始化（bean生命周期）也包括很多步骤1.2.3.。。。n，即需要了解在第几步完成
属性注入的呢？

下面看spring如何初始化一个bean的过程：
首先理解bean和java对象的概念
bean一定是java对象，但是java对象不一定是bean对象。

class------>BeanDefinition------->

先看普通类的实例化过程 .java---->.class----->java对象
再看spring bean的实例化过程：
java----->class------>并不是直接new对象放到spring容器中，因为有些是原形类型，有些是懒加载，而是把类的一些信息拿到放入到beanDefinition子类对象中。
然后把对应的BeanDefintion对象放入到map里，-------> 然后遍历map拿到类的一些信息进行new出来对象放入到单例池中。
实例化过程中，在生成BeanDefinition和new出对象之间spring预留了一个扩展方法接口，用于spring扩展。


bean实例化过程：
先做一系列校验判断（beanname合法，是否懒加载，是否单例） 
然后再去单例池中根据name 获取，获取不到
然后再判断是否在创建实例过程中（不涉及循环依赖，所以false），
然后再进行一系列校验
进行java对象的初始化，然后进行属性注入，最后完成bean实例化

涉及到的map缓存

1 singletonObjects 单例池，也就是通俗意义上的spring容器
2 singletonFactories 工厂对象，半成品所在地, why?可以对这个半成品进行加工升华，为什么需要升华加工半成品bean?代理，  可以处理aop。   
3 earlySingletonObjects 和1几乎一样，2级缓存删除出来，放入到3级缓存中。

为啥弄了三级缓存？
防止重复创建
对于Class C{
   A a;
}

A类bean实例化，首先对象初始化，如果支持循环依赖，把对应的工厂放入第二个缓存中，其中属性B需要注入，getBean(B),首先判断B是否实例化（没有），从容器中拿，
拿不到，进而从第三个缓存中拿，也拿不到，开始new B，进而注入属性A，getBean(A),这个时候就可以拿到了{从单例池拿不到&&正在创建过程中，从第二个缓存中拿到}
半成品，只是对象，不是bean实例



