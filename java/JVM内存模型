JVM内存分为
1 程序计数器，线程私有，当前线程所执行字节码的行号指示器，是唯一java虚拟机的没有规定OutOfMemoryError

2 java虚拟机栈，生命周期与java线程执行结果相同，每个线程都有自己的一个虚拟机栈，栈中的结构是栈帧，当调用一个方法时，会为方法创建一个栈帧。
     栈帧结构主要包括操作数栈，局部变量表，方法出口
     线程请求的栈深度大于虚拟机规定的栈深度，则报StackOverFlowError,如果栈空间动态扩展，申请不到足够内存，报OutOfMemoryError
     
3 本地方法栈，与本地方法栈类似，区别在于java虚拟机栈主要执行java类方法，本地方法栈主要执行native方法

上面都是线程私有的

4 堆，java虚拟机管理内存最大的一块区域，堆主要存放对象实例和数组，分为新生代，老年代，新生代有分为Eden和Survivor区，
     堆主要是GC关心的区域，当堆空间不足，无法完成对象分配时，会报OutOfMemoryError错误。  -Xmx(最大值), -Xms（最小值）
     
5 方法区，方法区是虚拟机区域的一种规范，HotSpot是使用永久代实现了方法区
         主要存放类信息，静态变量和常量。
         回收对象主要是一些无用的类和常量
         内存空间不足，也会报OutOfMemoryError
         
JVM运行原理

public class JVMCase{
    //常量
    public final static String MAN_SEX_TYPE = "man";
    //静态变量
    public static String WOMAN_SEX_TYPE = "woman";
    public static void main(String []args){
        Student stu = new Student();
        stu.setName("mick");
        JVMCase jvmcase = new JVMCase();
        //静态方法
        print(str);
        //非静态方法
        jvmcase.sayHello(stu);
    }
    //静态方法
    public static void print(Student stu){
        System.out.println(stu.name);
    }
    //非静态方法
    public void sayHello(Student stu){
        System.out.println(stu.name);
    }
}
Class Student{
    String name;
    get()
    set()
}

处理过程：
1 JVM向操作系统申请内存，JVM第一步通过参数配置或者默认配置申请内存空间，
2 JVM获取内存空间后，根据具体配置参数分配具体堆，栈，方法区内存大小
3 class文件加载，验证，准备及解析，
  3.1 准备阶段会为类的静态变量分配内存，初始化为系统的初始值
  3.2.。。
  
4 进行最后的初始化，在这个阶段，JVM会执行构造器方法（静态变量赋值，静态代码块，静态方法）
5 执行方法，启动main线程，执行main方法，首先在堆中创建一个student对象，对应对象引用存放栈中，
6 创建JVMCase对象，调用非静态方法sayHello，方法入栈， 在调用静态方法print,再放入栈中，


GC
why? 1 提高系统性能， 2 排查内存问题（溢出，泄露）
what?
那些区域需要回收：堆（无用对象）和方法区（无用类和无用常量）
那些对象需要回收：引用计数法（给对象添加引用计数器，每有对象引用，对应计数加1，引用失效，计数减1，计数为0，表示可以被回收）
                          （优点，实现简单，缺点，循环引用问题）
                可达性分析（通过一系列被称为GCRoot的对象作为起始点，从起始点搜索的路径为引用链，当一个对象没有跟任何一个引用链关联，此对象不可用）
                GCRoot(1方法区中静态变量引用的对象，2虚拟机栈中引用的对象，3本地栈方法中引用的对象，4方法区中常量引用的对象)
when? 达到minor gc或者Full gc的触发条件
      minor gc: Eden空间不足，触发minor gc
      minor gc是如何避免全堆扫描的？即如果有老年代的对象引用了新生代的对象，是不是还得扫老年代对象，解决：卡表，记录是否有引向新生代，这要只要遍历卡表就行，
      full gc : 1 调用system.gc,系统建议执行，不是必须执行 
                2 老年代空间不足
                3 方法区空间不足
                4 由Eden区和from survoior向to survoior区复制时，to survoior区空间不足，把对象转移到老年代且老年代空间也不足
      啥时候年轻代区域对象会进入老年代区域：
                1 如果对象熬过多次young gc依然存活，超过一直阈值，可移入老年代
                2 经过younggc完后，发现存活的对象很多，s区域放不下的对象，也会进入老年代
                3 大对象也会放入老年代
how?                
标记清除：该算法分为标记和清除两个阶段，首先标记需要回收的对象，然后进行统一回收，容易有碎片
标记整理：该算法分为标记和整理两个阶段，首先标记需要回收的对象，然后让存活的对象整理到一边，最后清除端边界以外的内存。
复制算法：新生代分为ende,fs,ts区域，每次使用Eden和其中一个survoior,回收对象时，将存活对象放入另外一个survoior，最后清理刚用的eden和sur
         有一部分空间用不了，浪费
分代收集：堆分为新生代和老年代，不同年代特点不同用不同的算法
         新生代，每次gc后只有少量对象存活，选择复制算法，只要付出少量对象的复制就可以完成回收
         老年代，对象存活率高，没有额外的空间担保，选择标记整理或者标记清除
         
收集器：

-XX:+UserParNewGC //并行收集器，年轻代复制算法
-XX:+CMSParallelRemarkEnabled  //Concurrent Mark Sweep,基于标记清除算法，一般用于老年代，
     1 初始标记  2 并发标记  3 重新标记  4 并发清除
     并发收集，低停顿，称为并发低停顿收集器，耗时长的处理过程（并发标记，并发清除）可以与用户线程一起工作，

具体垃圾回收器
1 serial 单线程的stop the world ,即正常工作线程运行，发现新生代空间不足则工作线程停止，单独一个垃圾回收线程进行复制算法回收
2 Serial-Old 针对老年代的回收器，使用标记清除/整理算法进行STW的回收。
上面两个针对刚才是内存空间相对较少，后面由于内存空间变大，针对一个线程处理显然处理不过来，由此引发后面的
3 parallel scavenge 针对新生代，复制算法，相对上述的就是变成多线程处理，但是会更在乎吞吐量和停顿时间，可以指定一些参数设置
4 parallel old 针对老年代
3+4 就是1.8默认的垃圾回收器，ps+po
后面空间越来越多，后面衍生出concurrent，并发，即工作线程+gc线程一起工作
5 CMS concurrent mark sweep,老年代，配合ParNew(新生代) 起工作
  初始标记-并发标记-重新标记-并发清除， 初始标记、重新标记 STW
  CMS存在内存碎片的问题，设置一些参数来规避：UseCMSCompactAtFullCollection（默认开启），即在fullGC的时候，进行内存碎片整理，
 随着内存区域越来越大，又不行了
6 G1摒弃了之前那种内存划分物理新生代老年代的方式，region部分回收，按照区域去处理，如果需要连续内存（大对象），放入humongous区域
  主要特点，标记整理不产生内存碎片，低停顿
  根据垃圾回收时间，回收优先级较高的区域，避免整个新生代或老年代的回收，
  为了避免扫描整个堆来判断对象是否可达，每个region分配一个Remeber Set，内部属于一个反向指针，记录了其他region对当前region引用的情况，这样可以避免回收整个region时，扫描整个堆
 
  痛点：需要把年轻代一次全部回收，因此诞生了ZGC，分页算法，
  
三色标记算法 用于并发标记阶段使用

java 逃逸分析

java源文件 ====javac===》.class  =====jvm解释====> 机器指令（不同语言不同种类）

分为两个阶段，在第二个阶段，JVM通过解释字节码将其翻译成对应的机器指令，追条读入，逐条翻译，经过解释执行，其执行速度必然比可执行二进制慢很多，为了解决
这个效率问题，引入了JIT（即时编译）
当JVM发现某个方法或者代码块运行很频繁时，会认为是热点代码，然后JIT会把热点代码翻译成本地机器相关的机器码，并进行优化，把翻译后的机器码缓存，以备后用

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传入其他地方，称为方法逃逸

作用：1 同步省略
动态编译同步块时，JIT编译器可以借助逃逸分析判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。
如果同步块所使用的锁对象通过分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块时会取消这部分代码的同步，即锁消除
