JVM内存分为
1 程序计数器，线程私有，当前线程所执行字节码的行号指示器，是唯一java虚拟机的没有规定OutOfMemoryError

2 java虚拟机栈，生命周期与java线程执行结果相同，每个线程都有自己的一个虚拟机栈，栈中的结构是栈帧，当调用一个方法时，会为方法创建一个栈帧。
     栈帧结构主要包括操作数栈，局部变量表，方法出口
     线程请求的栈深度大于虚拟机规定的栈深度，则报StackOverFlowError,如果栈空间动态扩展，申请不到足够内存，报OutOfMemoryError
     
3 本地方法栈，与本地方法栈类似，区别在于java虚拟机栈主要执行java类方法，本地方法栈主要执行native方法

上面都是线程私有的

4 堆，java虚拟机管理内存最大的一块区域，堆主要存放对象实例和数组，分为新生代，老年代，新生代有分为Eden和Survivor区，
     堆主要是GC关心的区域，当堆空间不足，无法完成对象分配时，会报OutOfMemoryError错误。  -Xmx(最大值), -Xms（最小值）
     
5 方法区，方法区是虚拟机区域的一种规范，HotSpot是使用永久代实现了方法区
         主要存放类信息，静态变量和常量。
         回收对象主要是一些无用的类和常量
         内存空间不足，也会报OutOfMemoryError
         
JVM运行原理

public class JVMCase{
    //常量
    public final static String MAN_SEX_TYPE = "man";
    //静态变量
    public static String WOMAN_SEX_TYPE = "woman";
    public static void main(String []args){
        Student stu = new Student();
        stu.setName("mick");
        JVMCase jvmcase = new JVMCase();
        //静态方法
        print(str);
        //非静态方法
        jvmcase.sayHello(stu);
    }
    //静态方法
    public static void print(Student stu){
        System.out.println(stu.name);
    }
    //非静态方法
    public void sayHello(Student stu){
        System.out.println(stu.name);
    }
}
Class Student{
    String name;
    get()
    set()
}

处理过程：
1 JVM向操作系统申请内存，JVM第一步通过参数配置或者默认配置申请内存空间，
2 JVM获取内存空间后，根据具体配置参数分配具体堆，栈，方法区内存大小
3 class文件加载，验证，准备及解析，
  3.1 准备阶段会为类的静态变量分配内存，初始化为系统的初始值
  3.2.。。
  
4 进行最后的初始化，在这个阶段，JVM会执行构造器方法（静态变量赋值，静态代码块，静态方法）
5 执行方法，启动main线程，执行main方法，首先在堆中创建一个student对象，对应对象引用存放栈中，
6 创建JVMCase对象，调用非静态方法sayHello，方法入栈， 在调用静态方法print,再放入栈中，


GC
why? 1 提高系统性能， 2 排查内存问题（溢出，泄露）
what?
那些区域需要回收：堆（无用对象）和方法区（无用类和无用常量）
那些对象需要回收：引用计数法（给对象添加引用计数器，每有对象引用，对应计数加1，引用失效，计数减1，计数为0，表示可以被回收）
                          （优点，实现简单，缺点，循环引用问题）
                可达性分析（通过一系列被称为GCRoot的对象作为起始点，从起始点搜索的路径为引用链，当一个对象没有跟任何一个引用链关联，此对象不可用）
                GCRoot(1方法区中静态变量引用的对象，2虚拟机栈中引用的对象，3本地栈方法中引用的对象，4方法区中常量引用的对象)
when? 达到minor gc或者Full gc的触发条件
      minor gc: Eden空间不足，触发minor gc
      full gc : 1 调用system.gc,系统建议执行，不是必须执行 
                2 老年代空间不足
                3 方法区空间不足
                4 由Eden区和from survoior向to survoior区复制时，to survoior区空间不足，把对象转移到老年代且老年代空间也不足
how?                
标记清除：该算法分为标记和清除两个阶段，首先标记需要回收的对象，然后进行统一回收，容易有碎片
标记整理：该算法分为标记和整理两个阶段，首先标记需要回收的对象，然后让存活的对象整理到一边，最后清除端边界以外的内存。
复制算法：
