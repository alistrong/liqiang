   因为存在并发访问，同一时刻对同一数据(临界资源)进行操作，如果不加控制可能会带来数据不一致问题，所以要进行并发控制。
   说起并发控制：锁，多版本控制mvcc(mutli version Concurrency controller)
   先说锁，最普通的锁，操作数据前，锁住，不允许其他并发任务操作，操作完释放锁
   普通的锁太暴力，其他人想读数据都无法并发执行，因此优化出现了共享锁和排它锁，共享锁之间不互斥，所以读读可以并行，排它锁和其他都互斥，所以看到如果写操作
没有执行完，其他读任务是无法进行的，对并发还是有一定的影响。
   有没有写任务没有完成但是其他读任务可能并发，因此引出了数据多版本。eg:
   最开始的数据版本是V0, T1时间，写任务1执行，将数据克隆一份，以版本号区分，对clone出来的数据V1进行修改，后面T2时候读任务可以读原来的V0数据，可以看到数
据多版本通过“读取旧数据”能够提高并发度。
   整个演进思路：普通锁：串行执行； 读写锁：读读并发； 数据多版本：读写并发
以上的思路针对innodb的应用：首先介绍redo日志，undo日志和回滚段
redo日志：针对数据库事务提交后，需要将更新后的数据刷到磁盘上，来保证数据的ACID特性，此优化的方式：先把操作更新到redo日志里面，再定期将数据刷到磁盘，即
         redo日志保证已提交的事务的ACID特性
undo日志：在事务操作为提交的时候，会将事务修改数据的镜像（原始的数据）存放到undo日志里，当事务回滚的时候，利用undo日志，撤销未提交事务对数据库的影响
         undo日志保证未提交事务的ACID特性
回滚段：即存放undo日志的地方。
    InnoDB是基于多版本并发控制的存储引擎
    first旧版本数据存储在回滚段里，InnoDB能够做到高并发是因为回滚段里的数据是历史数据的快照，select语句随便并发读取他们。
    快照读，这种一致性不加锁的读。除非自己显示加锁，默认的select语句都是快照读
    
    
下面介绍InnoDB七种锁：
自增锁：特殊的表级别锁专门针对事务插入auto_increment语句，最简单的情况一个事务正在往表里插入记录，其他所有事务的插入等待，保证插入的行是连续的主键。
共享、排它锁：S,拿到S可以读取这一行,拿到X可以修改或删除对应的记录,SS可以并发，SX互斥，解决方式多版本控制
意向锁：意思是事务可能要加共享或者排它锁了，先提前声明一个意向，意向锁是一个表级别的锁，又细分为意向共享锁和意向排它锁
插入意向锁：对于已有数据的修改和删除必须加强互斥锁，对于数据的插入，插入意向锁是间隙锁的一种，多个事务在同一个索引同一范围区间插入记录如果插入的位置不冲突
           不会阻塞彼此
1记录锁：它封锁索引记录，eg. select * from t where id =1 for update，他会在id=1的记录上加锁，阻止其他事务对id=1记录的插入，更新和删除。
2间隙锁：封锁索引记录中的间隔，主要目的是防止其他事务在间隔中插入数据，导致不可重复读，如果隔离级别是读提交，间隙锁自动失效
3临键锁：记录锁和间隙锁的结合，他封锁的范围既包含索引记录又包含索引区间

总结：
innoDB使用共享锁，可以提高读读并发
innoDB使用插入意向锁，可以提高插入并发

下面介绍InnoDB的可重复读的隔离级
普通的select就是上述的快照读，一种不加锁的一致性读
对于加锁的select,update,delete,他们的锁依赖于他们是否在唯一索引上使用了唯一的查询条件或者范围查询条件。唯一查询用记录锁（行锁），范围查询用间隙或临键
下面介绍InnoDB的读提交隔离级别
普通读就是快照读
加锁的select，update,delete语句一般用记录锁，可能出现读取幻影数据
