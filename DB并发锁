   因为存在并发访问，同一时刻对同一数据(临界资源)进行操作，如果不加控制可能会带来数据不一致问题，所以要进行并发控制。
   说起并发控制：锁，多版本控制mvcc(mutli version Concurrency controller)
   先说锁，最普通的锁，操作数据前，锁住，不允许其他并发任务操作，操作完释放锁
   普通的锁太暴力，其他人想读数据都无法并发执行，因此优化出现了共享锁和排它锁，共享锁之间不互斥，所以读读可以并行，排它锁和其他都互斥，所以看到如果写操作
没有执行完，其他读任务是无法进行的，对并发还是有一定的影响。
   有没有写任务没有完成但是其他读任务可能并发，因此引出了数据多版本。eg:
   最开始的数据版本是V0, T1时间，写任务1执行，将数据克隆一份，以版本号区分，对clone出来的数据V1进行修改，后面T2时候读任务可以读原来的V0数据，可以看到数
据多版本通过“读取旧数据”能够提高并发度。
   整个演进思路：普通锁：串行执行； 读写锁：读读并发； 数据多版本：读写并发
以上的思路针对innodb的应用：首先介绍redo日志，undo日志和回滚段
redo日志：针对数据库事务提交后，需要将更新后的数据刷到磁盘上，来保证数据的ACID特性，此优化的方式：先把操作更新到redo日志里面，再定期将数据刷到磁盘，即
         redo日志保证已提交的事务的ACID特性
undo日志：在事务操作为提交的时候，会将事务修改数据的镜像（原始的数据）存放到undo日志里，当事务回滚的时候，利用undo日志，撤销未提交事务对数据库的影响
         undo日志保证未提交事务的ACID特性
回滚段：即存放undo日志的地方。
    InnoDB是基于多版本并发控制的存储引擎
    first旧版本数据存储在回滚段里，InnoDB能够做到高并发是因为回滚段里的数据是历史数据的快照，select语句随便并发读取他们。
    快照读，这种一致性不加锁的读。除非自己显示加锁，默认的select语句都是快照读
