1.数据库事务的特性
  原子性：事务包含的操作要不全做，要不全不做；
  一致性：事务的操作使数据库从一个一致性状态到另一个一致性状态。事务的执行之前和执行之后都必须处在一致性状态；
  隔离性：多个并发事务操作要相互隔离；
  持久性：一个事务一旦提交，其操作的结果的数据改变是永久性的；即便数据库遇到故障也不会丢失提交的事务操作；
2.事务隔离级别
  脏读:一个事务的操作范围内，读取到同一数据的结果可能不一样，这是因为在读取过程中，读取到另外一个事务未提交的数据。即read uncommitted.
  不可重复读：一个事务操作范围内，前后读取的数据不一样，在读取过程中，另一个事务对这个数据进行了修改并提交。即read committed，若有事务读取数据时，要
            等待更新数据事务提交之后再读取数据。
  幻读：一旦事务读取开始，不能对该记录进行修改（主要针对update语句，但是insert），避免不可重复读，但是有可能出现幻读，在读取整体的数据时，是A，
       同时另一个事务提交了一个记录，导致最后读取到的整体和之前A又不一致，出现了幻读，repeated read.数据库默认的隔离级别。
  序列化：
3.数据库索引分类及实现方式
  索引：顾名思义，可以加快查询速度
  唯一索引：每一个索引值对应唯一的一条记录，一个表可以有多个唯一索引，且允许null
  主键索引：是唯一索引的一种特殊情况，一个表默认给主键建立主键索引，一个表一个，可以作为外键。非null,
  聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同,一个表只有一个聚集索引
  
  建立联合索引时，指定索引列的顺序很重要，当建立多列索引时，根据业务需要，使用最频繁的列放在最左边
  最左前缀原则：最左优先，以最左边开始连续的索引都能匹配上
4.mysql 两种存储引擎
  最著名是InnoDB和MyISAM
  先介绍一些基本数据结构：二叉树，平衡二叉树(AVL)，红黑树，B树，B+树
  B树优于红黑树的地方在于多路查找
  m阶B树：1.根节点至少两个子树；2.非根节点的关键字的个数 m/2-1<=K<=m-1;3.非根节点的度是关键字+1；4.所有叶子节点在同一层。
  m阶B+树：相对于B树差异两点。1：m个关键字的子树为m个；2:非叶子节点只存储关键字，叶子节点会包含所有的关键字信息及指向含有关键字记录的指针，
           所有叶子节点依照关键字的大小顺序链接
  以主键为索引的称为主索引，其以其他键而建的索引称为辅助索引
  两个存储引擎的区别在于：1.辅助索引的设计不同；2.MyISAM的文件和索引是分离的，InnoDB不是
  1的解释：MySAIM的辅助索引跟主索引差不多，而InnoDB的辅助索引的叶子节点存储是是主键
  2的解释：MySAIM的叶子节点存储的是记录的地址。而InnoDB的叶子节点存储的是全部数据，即文件和索引在一起
  假如改变了一个记录的地址，对于MySAIM而言，所有的索引都需要调整，但是对于InnoDB而言，只需要改变主索引
  另外两个存储引擎的区别：3.InnoDB是支持事务的，MySAIM不支持；4.InnoDB是支持外键，MySAIM不支持；5.InnoDB没有保留行数属性，统计时需要全表扫描，
  而MySAIM有记录关于表的行数属性；6.InnoDB不支持fulltext索引，MySAIM支持全文索引；7.InnoDB支持行锁，MySAIM不支持。
  总体而言，对于修改多（支持行锁），安全性要求高的数据库而言，InnoDB是合适的。对于大量的select操作，MySAIM优于InnoDB(索引和文件分离，对索引有压缩)
5.对于Hash索引的介绍：通过哈希函数，找到对应的记录
  如果是等值查询，毫无疑问hash索引更快。但是不支持范围查询，不支持利用索引排序，对于大量重复键的记录也不适合
6.数据库锁
  乐观锁：事务在进行操作时，认为操作的数据是没有人去修改的，因此都不加锁，因此在更新数据之前需要判断数据有没有改变，CAS或者版本号控制
  悲观锁：对数据进行操作之前，认为别人会修改数据，因此加锁，
  排它锁（写锁）：如果事务对数据加上排它锁后，其他事务不能对数据加任何类型的锁。
  共享锁（读锁）：如果事务对数据加上共享锁后，其他并发的事务也可以申请该数据的共享锁，但是任何事务不能对数据进行修改，
  行级锁：是一种排它锁，防止事务修改此行
  表级锁：锁定整个表，简单，但是并发效率低，易冲突。分5个级别
    
7.索引规范
  索引不是越多越好，过多的索引会严重影响数据插入和更新效率
  需要建索引的字段：order by, group by, distinct,where ,join 
  索引字段禁止策略：1 %前导；2 not in/like;3 区分度低，比如性别；4 不能在索引列进行数学和函数运算
  索引字段顺序考虑每个字段去重之后的数量，区分度最大（个数最多）的放在前面
  
  
  sql语句优化：
  使用limit对查询结果限定；
  少用select*,只去需要的列，避免无谓IO.cpu和网络开销;
  避免大SQL，将复杂sql拆分多条简单sql;
  Or改成IN ：OR的效率是n级别 ，IN的效率是log(n)级别，in的个数建议控制在200以内。
  减少mysql端的数学运算和逻辑判断；
  where 条件避免使用!=操作符，否则会放弃索引，进行全表扫描。
  where 条件字段类型和传入的类型保持一致，避免隐式转换 eg code varchar(50) where code = '1000'(使用索引) where code =1000(不使用索引)
  分页优化：select * from table limit 1000,10 偏移越大越慢。select * from table where id >=() limit 10;
  因为分页语句查询的时间和起始记录的位置成正比，
  
8.设计mysql表需要注意的地方
  表字段避免null值出现，一方面因为占用索引，另外一方面很难查询优化，推荐使用0来代替null
  尽量使用int而非bigint，非负的话加上unsigned，这样数值容量扩大一倍，当然能使用tinyint，smallint和mediumint更好。
  使用枚举类型或者整形代替字符串类型
  关于存储时间的tip：
  1 切记不要用字符串，虽然简单直白，但是字符串一方面占用的空间大，字符串存储的日期比较效率低(逐个字符比较)，无法用日期相关API进行计算和比较。
  2 对于timeStamp和dateTime的比较
   2.1 dateTime没有时区概念，timeStamp有时区概念
   2.2 dateTime空间耗费更大，8个字节，timeStamp空间相对较少，但是表示范围更小，占4个字节
  尽量使用timestamp代替datetime
  整形存ip
  _______________________
  
  数据库优化
  1 硬件
  2 系统配置
  3 数据库表结构
  4 sql语句及索引
  
  
