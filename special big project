1 12306(高并发，秒杀系统)

1.1
高并发的系统架构都采用分布式集群部署，服务上层有着层层负载均衡
nginx负载均衡，（轮询，加权轮询，ip hash轮询） 
nginx实现负载均衡主要通过upstream模块实现，
通过负载均衡将不同流量划分到不同机器上，每次机器处理好自己的请求，

1.2
当用户并发请求到达服务端时，关于订单，库存，付款操作流程
思路1 首先创建订单，然后扣除库存，等待用户支付，这种惯性思维保证订单不超卖，但是高并发情况下，创建订单都会访问数据库， 另外如果存在恶意下单但是不支付情况
      库存会变少，（可利用限制IP和用户的购买订单数量来优化）
思路2 创建订单，等待用户支付订单再减库存，不会少买，但是用户会创建很多订单，最后发现支付不了。
思路3 预扣库存，用户请求来了，先预扣库存，请求接口返回，然后丢消息总线去创建订单，返回订单信息给用户，然后用户再去支付

由于上述两种方案都有创建订单，就会频繁操作数据库，所以就先预扣库存，保证不超卖，然后异步生成用户订单，
对于预扣库存，还有一点优化的空间，即库存存在哪里？如何保证高并发下，正确的扣库存还能快速响应用户的请求
优化方案：本地扣库存，把一定的库存量分配到本地机器，直接在内存中减库存，然后按照之前的逻辑异步创建订单，这样避免了对数据库频繁的IO操作，只在内存中做运算
         高并发情况下，如何保证高可用，假如有两三台机器扛不住并发流量宕机了，就会有少买的情况，解决这个问题，需要对总订单做统一管理，下面有容错方案
高可用下的容错方案：服务器不仅要在本地减库存，还要远程统一减库存，为每台机器分配多余量防止宕机的情况， 即我们用redis存储统一库存，因为Redis性能非常高，      
         
         
//另外一个维度讨论秒杀系统
要求：高性能（承载高读写），一致性（同一时间数据改变，如果保证准确性），高可用（业务流量突增，依赖服务不稳定，保证高效运行）

高性能：
1 动静分离
  1.1 数据拆分，将动态页面改造成适合缓存的静态页面，分离出动态数据
      用户信息，包括登录状态及登录画像等
      时间，秒杀时间由服务端统一管控，
  1.2 静态缓存
      分离出动静数据后，将静态数据进行合理缓存，
      1.2.1 怎么缓存 直接缓存整个HTTP连接
      1.2.2 哪里缓存 浏览器,CDN,服务端
  1.3 数据整合
2 热点优化
  2.1 热点操作 零点刷新，零点下单等属于用户行为，不好改变，但是可以做一些限制保护，比如用户频繁刷新页面时进行提示阻断
  2.2 热点数据 
     2.2.1 识别热点数据 异步采集交易链路各个环节的热点key信息，提前识别热点数据，
     2.2.2 热点隔离 不要让1% 影响99%的，业务隔离，系统隔离，数据隔离
     2.2.3 热点优化，热点缓存，限流
3 系统优化
  提高性能，提升硬件水平，调整JVM参数，关注代码层面的优化
    减少序列化，尽量减少RPC调用，将多个强关联性的应用进行合并部署
    直接输出流数据，涉及字符串的IO操作，无论是磁盘IO还是网络IO，都比较消耗CPU
    裁剪日志异常堆栈
          
一致性：
库存是关键数据，卖不出去和超卖都是问题，保证扣减的准确性
业界最常见的是预扣库存，下单后有个有效期，超过时间订单自动释放
预扣库存要解决恶意下单，保证卖出去
结合安全和反作弊
还有避免超卖，即完全不允许库存为负，多种方案
1 通过事务判断，保证减后库存不能为负，否则回滚
2 直接设置数据字段类型是无符号整数，一旦库存为负，在执行SQL报错

针对一致性的优化
库存是关键数据，也是热点数据，对系统来说，热点的实际影响就是高读，高写
解决高并发读问题：
分层校验，在读链路时，进行不影响性能的检查操作，如用户是否具有秒杀资格，是否非法请求，而不做一致性等容易引起瓶颈的检查操作；直到写链路时，才对库存
做一致性检查，在数据层保证最终准确性，可以利用分布式缓存或者LocalCache来抵抗高并发读，允许一定场景的脏数据，等到真正写数据时再保证最终一致性
核心思想：不同层次可能过滤掉无效请求，只在漏斗最末端进行有效处理，从而缩短系统瓶颈的影响路径
解决高并发写问题：
  更新DB类型：秒杀商品核心在于数据量级小，交易时间短，是否可以直接把秒杀减库存放到缓存系统中，在一个带有持久化功能的缓存进行减库存的操作
  优化DB性能：由于库存数据落地到数据库实现其实是一行存储，因此会有大量线程来竞争INNODB锁。但并发越高，等待线程越多，TPS下降，RT上升，吞吐量严重影响
    解决并发锁问题：1 应用层排队，通过缓存加入分布式锁，控制集群对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接数量
                  2 数据层排队，
              
  
  
高可用：
1 流量削峰
   对于秒杀场景，最终有效请求的额度是有限的，并发度越高，无效请求越多，可以设计一些规则，人为的延缓秒杀请求，甚至可以过滤一些无效请求
   1.1 答题，即在入口处消减流量，防止作弊， 延缓请求
   1.2 排队，使用消息队列，把同步请求转换成异步的间接推送缓冲瞬时流量，但是也有弊端，请求积压，用户体验（异步的原因可能导致先发后至）
   1.3 过滤，分层，通过在不同层次过滤无效请求，达到数据读写的精准触发

  
      
