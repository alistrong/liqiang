1   全局唯一id生成
背景：分布式系统会对业务进行拆分，数据量巨大导致一个表不能承受，就需要对其进行分库分表，由于涉及到分库分表就引申出分布式唯一主键ID生成的问题。
需求：1 ID唯一，2 数字类型且自增， 3 ID简短，效率高
目前唯一id生成方案如下：
1.UUID 优点：代码简单；本地生成，没有性能问题；ID全球唯一，迁移没问题；
       缺点：ID无序，不保证自增；字符串类型，性能稍差；存储空间大；可读性差
       使用场景：token令牌生成，
2.mysql自增主键 优点：数字唯一且自增；查询效率高；可读性强
               缺点：存在单点问题（mysql挂了，就有问题了）；数据库压力大，并发扛不住
  针对mysql单点问题：部署多个实例，设置step歩长 （1 初始值是1（5,9,13） 2 初始值是2（6,10,14） 3初始值是3（7,11,15） 4初始值是4（8,12,16））
                    无法扩容，还是压力大，并发有问题。
3.雪花snowflake算法：生成64位二进制正整数，然后转化为十进制数
                    1bit(0 不用)
                    41bit时间戳，存储的是时间戳差值，当前时间戳-开始设置的时间戳。
                    10bit机器码，即可以部署到1024个节点上，也可以设置5位机房+5位机器节点
                    12bit序列号，毫秒内的计数，即每个节点1毫秒生成4096个数
                    优点：每秒产生很多ID，并发量高；时间戳在高位，自增序列在低位，整个ID是趋势递增，按照时间有序递增；灵活度高，根据业务需求调整bit位
                    缺点：依赖机器时钟，如果服务器时钟回拨，导致重复ID生成。
 4.redis生成方案：利用redis incr自增，一般算法为： 年份+当天距当年多少天+天数+小时+redis自增
                 优点：有序递增，可读性强
                 缺点：占用带宽，每次要向redis进行请求
以上是简单罗列方案，大厂对高并发和高可用和安全性等方面都有要求，下面罗列大厂的id生成方案，都是对以上某些技术的改进
1 数据库主键自增改进：针对步长固定，不容易扩容和并发量导致数据库压力大两个问题
                    针对压力大，是每次获取id都是访问数据库，可不可以不用每次都去数据库访问，思路是获取ID的时候，获取一个区间的。
                    ID规则表：id,业务说明，max_id,step,desc,update_time
                    
  1 应用如下： 用户服务注册用户时，需要一个用户ID，请求IDC服务;
              IDC服务去查数据库，找到业务user_tag的id，对应的max_id为0，step =1000;
              IDC返回给用户服务max_id和step，并把对应业务user_tag的max_id设置max_id+step;
              用户服务得到max_id=0，step=1000.这时候用户服务就可以使用ID=[max_id+1,max_id+step]的id了，把这个区间保存在JVM中，
              每次用户资料需要ID时，在区间[]内通过AtomicLong中的getAndIncrement方法来获取。
              区间内的用完了就可以在调IDC服务获取。
  1 的方案有竞争问题，多个用户服务同时获取ID服务时，在获取max_id时会有并发问题，解决方案：1 加分布式锁，同一时刻只有一个用户服务可获取，2 利用事务加
               行锁，没有执行完，不允许第二个用户资料服务请求过来。
  1 对于并发导致的加锁解决方案的优化：双buffer方案，JVM本地缓存中有两个buffer1(1-1000) buffer2(3000-4000),现在buffer1中获取，当获取达到区间的10%时
              先判断buffer2有没有去获取过，没有立即发起请求获取ID线程，把获取到的ID放入buffer2中，如果buffer1用完了，就自动切换到buffer2，当buffer2
              用到10%时，再次启动线程获取，放入buffer1中，依次往返。(机制，有一个线程会观察什么时候去自动获取，)解决突发阻塞的问题。
              
                    
