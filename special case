1   全局唯一id生成
背景：分布式系统会对业务进行拆分，数据量巨大导致一个表不能承受，就需要对其进行分库分表，由于涉及到分库分表就引申出分布式唯一主键ID生成的问题。
需求：1 ID唯一，2 数字类型且自增， 3 ID简短，效率高
目前唯一id生成方案如下：
1.UUID 优点：代码简单；本地生成，没有性能问题；ID全球唯一，迁移没问题；
       缺点：ID无序，不保证自增；字符串类型，性能稍差；存储空间大；可读性差
       使用场景：token令牌生成，
2.mysql自增主键 优点：数字唯一且自增；查询效率高；可读性强
               缺点：存在单点问题（mysql挂了，就有问题了）；数据库压力大，并发扛不住
  针对mysql单点问题：部署多个实例，设置step歩长 （1 初始值是1（5,9,13） 2 初始值是2（6,10,14） 3初始值是3（7,11,15） 4初始值是4（8,12,16））
                    无法扩容，还是压力大，并发有问题。
3.雪花snowflake算法：生成64位二进制正整数，然后转化为十进制数
                    1bit(0 不用)
                    41bit时间戳，存储的是时间戳差值，当前时间戳-开始设置的时间戳。
                    10bit机器码，即可以部署到1024个节点上，也可以设置5位机房+5位机器节点
                    12bit序列号，毫秒内的计数，即每个节点1毫秒生成4096个数
                    优点：每秒产生很多ID，并发量高；时间戳在高位，自增序列在低位，整个ID是趋势递增，按照时间有序递增；灵活度高，根据业务需求调整bit位
                    缺点：依赖机器时钟，如果服务器时钟回拨，导致重复ID生成。
 4.redis生成方案：利用redis incr自增，一般算法为： 年份+当天距当年多少天+天数+小时+redis自增
                 优点：有序递增，可读性强
                 缺点：占用带宽，每次要向redis进行请求
以上是简单罗列方案，大厂对高并发和高可用和安全性等方面都有要求，下面罗列大厂的id生成方案，都是对以上某些技术的改进
1 数据库主键自增改进：针对步长固定，不容易扩容和并发量导致数据库压力大两个问题
                    针对压力大，是每次获取id都是访问数据库，可不可以不用每次都去数据库访问，思路是获取ID的时候，获取一个区间的。
                    ID规则表：id,业务说明，max_id,step,desc,update_time
                    
                    
