1   全局唯一id生成
背景：分布式系统会对业务进行拆分，数据量巨大导致一个表不能承受，就需要对其进行分库分表，由于涉及到分库分表就引申出分布式唯一主键ID生成的问题。
需求：1 ID唯一，2 数字类型且自增， 3 ID简短，效率高
目前唯一id生成方案如下：
1.UUID 优点：代码简单；本地生成，没有性能问题；ID全球唯一，迁移没问题；
       缺点：ID无序，不保证自增；字符串类型，性能稍差；存储空间大；可读性差
       使用场景：token令牌生成，
2.mysql自增主键 优点：数字唯一且自增；查询效率高；可读性强
               缺点：存在单点问题（mysql挂了，就有问题了）；数据库压力大，并发扛不住
  针对mysql单点问题：部署多个实例，设置step歩长 （1 初始值是1（5,9,13） 2 初始值是2（6,10,14） 3初始值是3（7,11,15） 4初始值是4（8,12,16））
                    无法扩容，还是压力大，并发有问题。
3.雪花snowflake算法：生成64位二进制正整数，然后转化为十进制数
                    1bit(0 不用)
                    41bit时间戳，存储的是时间戳差值，当前时间戳-开始设置的时间戳。
                    10bit机器码，即可以部署到1024个节点上，也可以设置5位机房+5位机器节点
                    12bit序列号，毫秒内的计数，即每个节点1毫秒生成4096个数
                    优点：每秒产生很多ID，并发量高；时间戳在高位，自增序列在低位，整个ID是趋势递增，按照时间有序递增；灵活度高，根据业务需求调整bit位
                    缺点：依赖机器时钟，如果服务器时钟回拨，导致重复ID生成。
 4.redis生成方案：利用redis incr自增，一般算法为： 年份+当天距当年多少天+天数+小时+redis自增
                 优点：有序递增，可读性强
                 缺点：占用带宽，每次要向redis进行请求
以上是简单罗列方案，大厂对高并发和高可用和安全性等方面都有要求，下面罗列大厂的id生成方案，都是对以上某些技术的改进
1 数据库主键自增改进：针对步长固定，不容易扩容和并发量导致数据库压力大两个问题
                    针对压力大，是每次获取id都是访问数据库，可不可以不用每次都去数据库访问，思路是获取ID的时候，获取一个区间的。
                    ID规则表：id,业务说明，max_id,step,desc,update_time
                    
  1 应用如下： 用户服务注册用户时，需要一个用户ID，请求IDC服务;
              IDC服务去查数据库，找到业务user_tag的id，对应的max_id为0，step =1000;
              IDC返回给用户服务max_id和step，并把对应业务user_tag的max_id设置max_id+step;
              用户服务得到max_id=0，step=1000.这时候用户服务就可以使用ID=[max_id+1,max_id+step]的id了，把这个区间保存在JVM中，
              每次用户资料需要ID时，在区间[]内通过AtomicLong中的getAndIncrement方法来获取。
              区间内的用完了就可以在调IDC服务获取。
  1 的方案有竞争问题，多个用户服务同时获取ID服务时，在获取max_id时会有并发问题，解决方案：1 加分布式锁，同一时刻只有一个用户服务可获取，2 利用事务加
               行锁，没有执行完，不允许第二个用户资料服务请求过来。
  1 对于并发导致的加锁解决方案的优化：双buffer方案，JVM本地缓存中有两个buffer1(1-1000) buffer2(3000-4000),现在buffer1中获取，当获取达到区间的10%时
              先判断buffer2有没有去获取过，没有立即发起请求获取ID线程，把获取到的ID放入buffer2中，如果buffer1用完了，就自动切换到buffer2，当buffer2
              用到10%时，再次启动线程获取，放入buffer1中，依次往返。(机制，有一个线程会观察什么时候去自动获取，)解决突发阻塞的问题。
             
             
 question2 : 短链-----》长链            
 自增id: 一种无碰撞的方法，每新增一个短码，就在上次添加的短码id基础上加1，然后将这个10进制的id值，转化成一个62进制的字符串。
        一般利用数据表中的自增id来完成，每次先查询表中目前最大的id，然后id+1 =====>62进制从而得到短码
        但是有个问题，短码数据库从一位长度开始，最后转成短码时有可能长度不固定，不过可以用id从指定的数字开始递增方式来处理，确保所有的短码长度一样。
        另外还有一个问题，由于递增有序，会有安全问题，可以将生成的短码id，结合长网址等关键字，进行md5运算生成最后的短码。
 摘要算法：又称为hash算法，输入任意长度的数据，输出固定长度的数据，相同的输入始终得到相同的输出，不同的输入尽量得到不同的输出。
          算法过程：1 将长网址MD5生成32位签名串，分为4段，每段8个字节；
                   2 对这四段循环处理，取8个字节，将他看成16进制串与0x3ffffff(30位1)与操作，即超过30位的忽略处理。
                   3 这30位分6段，每5位的数字作为字母表的索引取得特定字符，依次进行获取6位字符串；
                   4 总的md5串可以获取4个6位串，取里面任意一个就可以作为最终结果。
          这种算法，仍然会存在重复几率，解决冲突比较麻烦，
 普通随机数：从62个字符串中随机取出一个6位短码的组合，然后去数据库中查询该短码是否已存在，如果已存在，重复刚才动作，重新获取返回。
            这种算法是一种简单的实现，不过由于Math.round是伪随机，碰撞的可能性也不小，在数据比较多的情况，可能循环很多次。

综合三种，自增容易被暴力破解，普通随机的又冲突的概率高，因此一般倾向选择摘要算法。
具体实现：
短网址采用域名和后缀分开存储的形式，另外域名需要区分HTTP还是HTTPS,hash方案针对整个链接进行hash，而不是除了域名外的链接。域名单独保存可以分析当前
域名下链接的使用情况。
另外一方面增加链接的有效期字段，一般有短链需求的可能是相关活动或者热点事件，一段时间很活跃，没必须永久保存，
对于过期数据的处理，可以在新增短链的时候判断当前短链的失效日期，因此数据库字段如下：
base_url; suffix_url; full_url ; shot_code; expiration_date; total_click_count

缓存方案：
查询需求，内存中增加缓存，LRU算法进行淘汰更新

如何跳转：
当浏览器输入：ed3wrFdA时
1 DNS解析ip地址，得到ip的地址，然后想这个ip地址发送HTTP请求，查询短码3333
2 访问服务器通过短码获取对应的长url。
3 通过HTTP301转到对应的长url
//why 302？301是永久重定向，302是临时重定向，有时候为了方便统计短链的一些数据。
