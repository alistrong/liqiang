java的内存模型
    每个线程都有自己的工作内存，而Java的内存模型规定所有的变量（包括实例字段，静态字段和构成数据对象的元素）存储在主内存中，而工作内存保存着该线程使用
到的变量和主内存拷贝副本，线程对变量的操作必须在工作内存中进行，而不能直接读写主存中的变量，不同线程之间也无法直接访问对方工作线程的变量，线程之间变量
值的传递通过主内存来完成。

了解Java内存模型的三个特征：
1.原子性：一个操作不可中断与分割，一个操作一旦开始就不会被其他线程干扰。一般认为对基本类型的读写操作是有原子性的，lock和unlock  synchronized也能保证
2.可见性：当一个线程修改了共享变量值，其他线程能立即得知修改，通过变量修改后将新值同步回主内存，volatile变量保证新值能立即同步主内存，synchronized和
         final也能实现可见性。
3.有序性：Java虚拟机会调整字节码顺序，单线程感知不到，多线程有可能出问题， Java提供了volatile和Synchronized关键字来保证串行执行
         Java虚拟机的优化有一些前提即 Happen-Before原则
         3.1 程序次序原则：一个线程内，按照代码顺序，书写在前面的操作先发生于书写在后面的操作
         3.2 volatile原则：volatile变量的写操作先于对volatile变量的读操作，保证volatile变量的可见性
         3.3 lock原则：unlock的操作必然先于lock的前
         3.4 传递性：A先于B,B先于C，则A先于C
 
volatile关键字
     我们知道volatile关键字保证有序性和可见性，但是不保证原子性，什么时候使用呢，运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量值
     具体可见性实现原理：在生成汇编指令时，针对线程写volatile变量会加入lock前缀指令，这个指令作用1：将当前缓存的变量值写会主内存，作用2:CPU里缓存了该内存
     地址的数据无效。
     有序性实现原理：会在指令序列中插入内存屏障来禁止特定类型的处理器重排序
线程安全与锁优化
如何实现线程安全：1.互斥同步,多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用常见的Java互斥同步手段是synchronized和concurrentLock
                 synchronized和lock都有可重入的特性，但是lock相对synchronized具有等待可以中断，公平锁和锁可以绑定多个条件，synchronized相对lock
                 不用手动释放锁                
                 2.非阻塞同步,互斥同步是线程进行阻塞和唤醒消耗性能，即一种悲观的并发策略，非阻塞就感觉没有冲突，如果有冲突就改用其他补救措施，
锁优化：我们知道互斥同步时，对性能最大影响是阻塞的实现，挂起线程和恢复线程需要转入内核态，这些操作给系统的并发带来了很大的压力。
1 自旋锁：我们发现共享数据的锁定状态持续的时间很短，为了这段时间去挂起和恢复线程不值得，我们可以让后面请求锁的线程稍等一下，但不放弃处理器，看看持有锁的
         线程会不会很快释放锁，为了让线程等待，我们只需让线程执行一个忙循环（自旋）
2 锁消除：虚拟机即时编译器运行时，对一些代码要求同步，通过JIT即时编译逃逸分析发现加锁的代码块或者对象 被检测到不可能存在共享数据竞争的锁进行消除。
          eg :stringbuffer.append()
3 锁粗化：一般原则下我们尽量将同步代码块的范围缩得很小，只在数据共享域才进行同步，但是有一系列连续操作对同一个对象反复加锁和解锁。或者每个同步块使用的
         是一个锁实例，JIT会在编译的时候将这些同步块合并成一个大同步块，并且是用同一个锁实例，避免一个线程反复申请释放锁。
4 轻量级锁：对于绝大部分锁，整个同步期间都不存在竞争的，轻量级锁所使用CAS操作避免使用互斥量的开销。
5 偏向所：对于绝大部分锁，整个同步期间都不存在竞争的的，相对于轻量级锁，偏向锁连CAS操作都不做了，这个锁就是偏于第一个获取它的锁，在接下来的执行过程中，该
         锁没有被其他线程获取，则持有偏向锁的线程永远不需要再同步。
         
 上面的锁优化是JVM虚拟机帮我们做的，对我们来说是透明的，如何在java代码中进行锁优化呢？即代码风格场景来说
 锁的开销主要在争用锁上，在多线程对共享资源访问时，会出现锁等待，为了降低这种开销
 1 减少临界区的范围
   减少临界区的长度即可以减少锁被持有的时间，从而降低锁被争用的概率，减少锁开销的目的。例如避免对一个方法进行加锁同步，只针对方法中的需要同步的资源
   进行同步，其他的代码不要放到synchronized中，减少临界区的范围。
 2 减少锁的颗粒度
   可以降低锁的申请频率，从而减少锁的争用概率。
   eg 四个方法 addUser  addQuery  removeUser  removeQuery 都用synchronized修饰，改为
      addUser removeUser 里用synchronized(user)  addQuery removeQuery 用synchronized(query) 
      即前两个方法的调用并不会影响后两个方法的调用，ConcurrentHashMap,SynchroizedMap就是利用了这种设计
 3 读写锁
 
 
             
乐观锁
   相对于synchronized悲观锁的思想，乐观锁是每次先执行操作，执行完检测是否与其他线程之间存在共享数据竞争，没有则操作成功，有则重试操作与检测，直到成功
乐观锁的核心思想是CAS，即内存值，预期值和新值，当且仅当预期值与内存值一样时，CAS肯定是具有原子性的，这个原子性是由CPU硬件指令实现保证的，非阻塞同步
   这种思想避免了悲观锁独占对象的现象，同时也提高了并发性能，但是下面列了CAS的一些问题及Java应对方式
     但是乐观锁只能保证一个共享变量的原子操作，如果多于一个变量，Java建议利用一个对象变量整个多个变量，一个类的成员变量就是共享变量，对这个对象进行CAS,
   即Java提供了AtomicReference来保证引用对象之间的原子性
     另外长时间的自旋导致开销大，
     第三方面ABA问题，解决思路是引入版本号，Java使用AtomicStampedReference来
     
再介绍synchronized优化前，先了解一下对象在内存中的存放以及对象头的一些概念：
在jvm中，对象在内存中分为三块区域：
1 对象头（1.1 mark word标记字段，存储对象hashcode,分代年龄，锁标志位，随着锁标志位变化而变化；1.2 Klass Point类型指针，指向类元数据的指针，通过这个
指针确定这个对象是那个实例）
2 实例数据（存放类的数据信息，父类信息）
3 填充对齐

synchronized获取对象的monitor，及对象的锁，那个对象的锁是什么概念呢，类似对这个对象的标识，这个标识就放在Java对象的对象头中，具体对象头（mark word）
 锁的状态：对象的hashcode（25bit）/ 对象分代年龄（4bit）/是否是偏向锁（1bit）/锁标志位（2bit）
 在SE1.6版本锁状态共有4种，无锁，偏向锁，轻量级锁，重量级锁，能升级不能降级
 初始化的对象，没有任何锁的情况，没有线程竞争，没有竞争的对象头信息如下：
   25bit没有使用/hashcode(31bit) /未使用（1bit）/对象分代年龄 (4bit)/偏向锁 0 （1bit）/ 锁状态 01 (2bit) //对象在survivor复制一次加1，最多15次
 当一个线程来竞争锁的时候，先用偏向锁，表示这个锁偏向这个线程，这个线程操作锁的关联代码不需要做任何检查和切换，这时，mark word会记录偏向的线程ID,
 这种竞争不激烈的情况下，效率非常高，具体对象头信息如下：
    线程ID(51bit) / 偏向时间戳(2bit) /未使用(1bit)/对象分代年龄(4bit)/偏向锁 1 (1bit) / 锁状态 01 (2bit)
 当两个线程开始竞争锁资源时，锁会升级，不再是偏向锁，升级为轻量级锁，公平竞争，那个线程先占有锁就执行代码，且锁对象mark word记录那个线程的栈帧锁记录
    指向线程的栈帧锁记录 (62bit)  / 锁状态 00 (2bit)
 当竞争这个锁的线程变得更多，此时升级为重量级锁，MarkWord再次变化为指向对象监视器，
    指向监视器对象  (62bit) / 锁状态 10 (2bit)
synchorized关键字使用：
1 用在实例方法上，eg public synchronized void get(){} //锁住的是当前实例对象
2 用在静态方法上，eg public static synchronized void get(){} //锁住的是当前class对象
3 用在代码块上， eg public void  get(){
                        synchronized(obj/A.class){ //锁类或者实例对象
                        
                        }
                   }
                   
Synchorized详解：
使用Synchorized关键字，关键是要获取对象的监视器，才能执行，否则要等待，而且这个获取过程是互斥的，即只有一个线程能获取到monitor，这种互斥的方式导致
使用性能下降，因此引入锁的优化，即将获取锁的时间缩短，
  大部分情况锁不存在多线程竞争问题，即由同一个线程多次获得，为了让线程获取锁的代价更低，即这种情况下引入了偏向锁，当一个线程获取锁进去同步代码块时
会在对象头和栈帧的锁记录里存储这个线程ID，以后该线程不需要通过CAS来获取和释放锁，只是简单测试mardword里存储里着指向该线程的偏向锁。
   当存在锁竞争问题时，解除偏向锁，进入轻量级锁，通过自旋方式来加锁，轻量级锁使用线程交替进入同步代码块里，尝试用CAS操作来获取锁，获取成功，改为00
        
