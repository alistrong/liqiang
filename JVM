java的内存模型
    每个线程都有自己的工作内存，而Java的内存模型规定所有的变量（包括实例字段，静态字段和构成数据对象的元素）存储在主内存中，而工作内存保存着该线程使用
到的变量和主内存拷贝副本，线程对变量的操作必须在工作内存中进行，而不能直接读写主存中的变量，不同线程之间也无法直接访问对方工作线程的变量，线程之间变量
值的传递通过主内存来完成。

了解Java内存模型的三个特征：
1.原子性：一个操作不可中断与分割，一个操作一旦开始就不会被其他线程干扰。一般认为对基本类型的读写操作是有原子性的，lock和unlock  synchronized也能保证
2.可见性：当一个线程修改了共享变量值，其他线程能立即得知修改，通过变量修改后将新值同步回主内存，volatile变量保证新值能立即同步主内存，synchronized和
         final也能实现可见性。
3.有序性：Java虚拟机会调整字节码顺序，单线程感知不到，多线程有可能出问题， Java提供了volatile和Synchronized关键字来保证串行执行
         Java虚拟机的优化有一些前提即 Happen-Before原则
         3.1 程序次序原则：一个线程内，按照代码顺序，书写在前面的操作先发生于书写在后面的操作
         3.2 volatile原则：volatile变量的写操作先于对volatile变量的读操作，保证volatile变量的可见性
         3.3 lock原则：unlock的操作必然先于lock的前
         3.4 传递性：A先于B,B先于C，则A先于C
 
volatile关键字
     我们知道volatile关键字保证有序性和可见性，但是不保证原子性，什么时候使用呢，运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量值

线程安全与锁优化
如何实现线程安全：1.互斥同步,多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用常见的Java互斥同步手段是synchronized和concurrentLock
                 synchronized和lock都有可重入的特性，但是lock相对synchronized具有等待可以中断，公平锁和锁可以绑定多个条件，synchronized相对lock
                 不用手动释放锁
                 
                 2.非阻塞同步,互斥同步是线程进行阻塞和唤醒消耗性能，即一种悲观的并发策略，非阻塞就感觉没有冲突，如果有冲突就改用其他补救措施，
锁优化：我们知道互斥同步时，对性能最大影响是阻塞的实现，挂起线程和恢复线程需要转入内核态，这些操作给系统的并发带来了很大的压力。
1 自旋锁：我们发现共享数据的锁定状态持续的时间很短，为了这段时间去挂起和恢复线程不值得，我们可以让后面请求锁的线程稍等一下，但不放弃处理器，看看持有锁的
         线程会不会很快释放锁，为了让线程等待，我们只需让线程执行一个忙循环（自旋）
2 锁消除：虚拟机即时编译器运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。stringbuffer.append()
3 锁粗化：一般原则下我们尽量将同步代码块的范围缩得很小，只在数据共享域才进行同步，但是有一系列连续操作对同一个对象反复加锁和解锁。
4 轻量级锁：对于绝大部分锁，整个同步期间都不存在竞争的，轻量级锁所使用CAS操作避免使用互斥量的开销。
5 偏向所：对于绝大部分锁，整个同步期间都不存在竞争的的，相对于轻量级锁，偏向锁连CAS操作都不做了，这个锁就是偏于第一个获取它的锁，在接下来的执行过程中，该
         锁没有被其他线程获取，则持有偏向锁的线程永远不需要再同步。
 


        
