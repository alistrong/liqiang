java的内存模型
    每个线程都有自己的工作内存，而Java的内存模型规定所有的变量（包括实例字段，静态字段和构成数据对象的元素）存储在主内存中，而工作内存保存着该线程使用
到的变量和主内存拷贝副本，线程对变量的操作必须在工作内存中进行，而不能直接读写主存中的变量，不同线程之间也无法直接访问对方工作线程的变量，线程之间变量
值的传递通过主内存来完成。

了解Java内存模型的三个特征：
1.原子性：一个操作不可中断与分割，一个操作一旦开始就不会被其他线程干扰。一般认为对基本类型的读写操作是有原子性的，lock和unlock  synchronized也能保证
2.可见性：当一个线程修改了共享变量值，其他线程能立即得知修改，通过变量修改后将新值同步回主内存，volatile变量保证新值能立即同步主内存，synchronized和
         final也能实现可见性。
3.有序性：Java虚拟机会调整字节码顺序，单线程感知不到，多线程有可能出问题， Java提供了volatile和Synchronized关键字来保证串行执行
         Java虚拟机的优化有一些前提即 Happen-Before原则
         3.1 程序次序原则：一个线程内，按照代码顺序，书写在前面的操作先发生于书写在后面的操作
         3.2 volatile原则：volatile变量的写操作先于对volatile变量的读操作，保证volatile变量的可见性
         3.3 lock原则：unlock的操作必然先于lock的前
         3.4 传递性：A先于B,B先于C，则A先于C
 
 volatile关键字
     我们知道volatile关键字保证有序性和可见性，但是不保证原子性，什么时候使用呢，运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量值
