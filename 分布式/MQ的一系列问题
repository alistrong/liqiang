1 MQ作用：
解耦，异步，削峰

2 业界常用的MQ
kafka             吞吐量高，10w，分布式，功能简单，常用语大数据，实时计算，日志采集
rabbitMQ          万级，基于主从实现高可用，erlang开发，性能好，社区活跃，图形管理完备
RocketMQ          阿里出品，吞吐量高，分布式，可靠，java实现

3 如何实现高可用
一说高可用就是当机器宕机时，有备机顶上去来保证
下面说一下高版本kafka的高可用性
即分布式的，多机器，有主从的
正常的一个主题下有多个分区（p1,p2,p3）
机器1（p1(leader),p2(follwer),p3(follwer)）
机器2（p2(leader),p1(follwer),p3(follwer)）
机器3（p3(leader),p1(follwer),p2(follwer)）
生产者连接对应的leader节点，生产消息时，其他follwer同步数据
消息者同样连接leader节点，
当master节点宕机时，会重新选主，超过半数投票，当master节点变更时，会通过注册中心下发通知给客户端。


4 MQ消费重复的问题
  每个消息都有一个offset标识这个消息的序号。
  可能重复消费的情况：消费者处理完offset=152后，没提交ack，机器重启，下发又消费到offset=152的消息
  结合业务场景解决方法：1 如果是写库，先主键查询一下，如何已经有了，别插入了，update一下
                      2 如果是redis，没问题，每次set，天然幂等
                      3 如何更复杂，发送数据时加一个唯一id，消费之后，根据唯一id查询，没消费就处理，消费过了就不处理。
                      
                      
5 MQ的可靠性保证
 生产者=-----=-----》 MQ-------------->消费者
 其中三个步骤都有可能出现丢失消息的情况。
 解决方案：
 1 客户端提供不同程度的发送消息ack级别，即对于客户端，每次发送消息，正常情况下都有ack,根据不同程序返回不同程度的ack，比如发送成功，send_ok
 leader_ok 主节点已经收到， master_flush_ok主节点已经刷盘。
   另外对于发送超时或者发送失败，默认会重试，从而保证消息发送的可靠性
   而对于异步发送，可以通过回调查看发送的情况，从而做业务处理
 2 持久化存储，与kafka一致，采用直接内存映射方式mmap，高效的异步刷盘
 3 消费者可以每次消费成功后，手动提交一下ack
 
6 MQ的顺序性 
                               ----->consumer1 msg2
生产者---msg1--msg2--msg3--->MQ ----->consumer2 msg1
                                ----->consumer3 msg3
 即消费者可能先处理msg3,再处理msg2，msg1
 解决方案：
 可以搞几个queue,有顺序的消息放入同一个queue里，然后对应一个consumer去消费，保证丢到队列里的是1,2,3,同样只有一个消费者去队列拿，肯定也是有序的。
 即一个队列对应一个线程去消费，保证有序的消息进入一个队列就行，这样即能保证有序，又可以保证不是单线程运行，保证效率。
 
 kafka的同一个partition的有序的，通过key一直，保证进入同一个parition里，然后1个partion里由一个consumer消费，如果一个consumer只有一个线程处理
 就是有序，但是一个consumer如果有三个线程同步并发执行消费，就有可能出现乱序
 解决方案：
 你就是有多个线程并发消费，咋办呢？搞内存队列，保证有序的消费放入同一个内存队列中
 内存队列1  -----> thread1
 内存队列2  -----> thread2
 内存队列3  -----> thread3
 
 7 MQ堆积
 首先恢复正常的消费端，然后配置更多点队伍，然后启动更多的consumer去消费。即加速消费
 
 
 8 设计MQ
 可支持扩容，分布式，每个partion是机器的一个节点，是topic的一部分数据
 可靠性，落盘，持久化
 高可用 leader-follower 选举
 数据丢失问题
 
       
