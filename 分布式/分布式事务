从大体上分类为以下两类：
1 刚性分布式事务（满足ACID）
  1.1 强一致性
  1.2 CAP满足 CP
  1.3 XA模型
    应用程序，数据库资源，事务管理
  
  具体的实现方式
  1.4 两阶段提交 2PC（XA模型的一种实现）
      第一阶段prepare投票，等待回复，协调者等待收到投票者的回复
      第二阶段commit提交，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；
     此方案的缺点：同步阻塞，锁定时间长，
  
2 柔性分布式事务（对XA协议模型妥协，通过降低强一致性要求，降低数据库锁定资源的时间，提高可用性）
  2.1 最终一致性
  2.2 CAP满足 AP
  2.3 base理论（基本可用，柔性状态，最终一致性）
  具体实现方式
  2.4 TCC模型(try【尝试执行业务，完成业务检查，预留资源】-confirm【真正执行业务】-cancel【回滚，释放】)
     完全由业务去实现，每个子业务都要实现TCC三个阶段，业务侵入性强
     example:A想B汇款，一个汇款服务，一个收款服务，
  
  2.5 saga
  
3 具体业务的解决模型
  本地事务---》短事务
  分布式事务---》长事务
  即转变成多个短事务
  A下单---B减库存-----C支付
  A,B成功，C失败---》进行补偿
  
  3.1 业务场景1 A操作完 发送MQ，B消费MQ执行操作
     （1）事务A发起方往MQ发送prepare消息
     （2）发送prepare消息成功后，A进行本地事务操作
     （3）根据本地事务操作成功与否发送commit消息或者rollback消息
     （4）如果是rollback消息，prepare消息删除不下发，如果是commit消息，进行commit消息提交给消费端
     （5）如果本地事务执行有问题（挂了），MQ服务端会专门起一个线程不断轮询判断prepare消息咋还没结果，去client查询本消息的结果
     缺点：业务侵入大，需要提供查询prepare消息的结果接口，消费端需要处理幂等，发送端发送消息非幂等，MQserver端专门轮询查。
     
     本地事务表：
     （1）事务A将本地业务操作和消息操作放到本地事务一起做，
     （2）然后去本地消息表读取消息，往MQ队列写入消息，然后如果收到MQ ack，则修改本地消息表。
  3.2 业务场景2 在业务逻辑层进行A,B操作。
  
     方案：基于异步补偿的分布式事务（fast-fail,即异步补偿，同步给用户返回结果）
     example: A操作完，B操作失败（B本地事务自己主动回滚），A如何补偿呢？尽量幂等
     
     
     
