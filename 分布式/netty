netty:高性能，异步事件驱动的NIO框架，提供了对TCP,UDP和文件传输的支持
      所有的IO操作都是异步非阻塞的，通过future-listener机制，用户可以主动获取或者通过通知机制获得IO操作结果
      高性能主要来源于I/O模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据
      
传统RPC调用性能差：
  1 网络传输方式：采用同步阻塞IO，当客户端并发压力大或者网络时延增加后，同步阻塞IO会由于频繁的wait导致IO线程经常性的阻塞，
    client--BIO--> new Thread()处理,
    采用同步阻塞IO，会导致每个TCP链接占用一个线程，而线程属于非常宝贵的资源，当IO读写阻塞导致线程无法及时释放时，到导致性能下降
  2 序列化方式：Java序列化是Java内部的一种对象编解码技术，无法跨语言使用，
               Java序列化后的流太大，无论是网络传输还是持久化到磁盘，都会导致额外的资源占用
               序列化性能差，cpu资源占用高
 
而如何保证高性能
1 传输：用什么样的通道将数据发给对方，BIO,NIO,AIO
2 协议：采用什么样的通信协议，HTTP或者内部私有协议，
3 线程：数据报如何读取？读取之后的编解码在那个线程进行，编解码后的消息如何派发，Reactor线程模型影响很大

下面看看netty的高性能之道
1 异步非阻塞通信
  IO通信时，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个selector的阻塞上。
从而系统在单线程的情况下可以同时处理多个客户端的请求，整体系统开销少，节省系统资源
下面是netty基于Reactor模型设计

NIOserver                                     Reactor Thread                             ioHandler
1 打开serversocketChannel
2 绑定监听地址 InetSocketAddress
                                            3 创建Selector，启动线程
4 将serversocketChannel注册到Selector    
                                            5 selector轮询就绪的key
                                            6 handleAccept()处理新的客户端接入     
                                                                                     7 设置新建客户端连接的socket
                                            8 向selector注册监听读操作
                                            9 handleRead异步读请求处理
                                                                                     10 decode请求
                                            11 异步写ByteBuffer到socketChannel
                                            
Netty的IO线程NioEventLoop由于聚合了多路复用器selector，可以同时并发处理成百上千个客户端channel，由于读写操作都是非阻塞的，可以充分提升IO线程的运行
效率，避免由于频繁IO阻塞导致线程挂起，另外由于netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，

线程模型
设计一个事件处理模型的程序：事件驱动方式，发生事件，主线程把事件放入事件队列中，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑事件，
reactor模型：
两个关键组件：
1 Reactor:在一个单独线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做反应
2 handler:处理程序执行IO事件要完成的实际事件
基于reactor和handler数量的不同，有三个变种
1 单Reactor单线程
2 单Reactor多线程
3 主从Reactor多线程
netty是基于主从Reactor多线程模型做了一定的修改
1 MainReactor负责客户端的连接请求，并将请求转交给subReactor
2 SubReactor负责相应通道的IO读写请求
3 非IO请求（具体逻辑请求）的任务写入队列，等待worker thread处理



2 0拷贝技术
 netty的接收和发送ByteBuffer采用DIRECT BUFFERS,即使用堆外直接内存进行socket读写，不需要二次拷贝
 这里描述的0拷贝，从宏观上解释，
 首先从字面理解就是数据不需要来回的拷贝，大大提升了系统的性能，应用于java nio,netty,kafka,RocketMQ等框架中，作为提升性能的一大亮点。
 1 I/O的概念
 缓冲区：IO的基础，I/O就是把数据移进或者移除缓冲区，进程进行IO操作就是向操作系统发起请求，让它要么把缓冲区的数据排干，要么填充缓冲区，
   用户空间              |           内核空间                    |
   缓冲区<------------(read)--------缓冲区<-------(DMA)-------磁盘控制器<----硬件-----磁盘
   进程
   
   用户进程发起read请求后，内核收到read请求命令之后，会检查内核空间是否已经存在进程所需要的数据，如果存在，直接copy数据给进程的缓冲区，如果没有，
   向磁盘控制器发命令，从磁盘读取数据，磁盘控制器把数据直接写入内核read缓冲区，通过DMA实现。
   接下来就是内核将数据copy到进程的缓冲区；如果进行发起write命令，同样需要把用户缓冲区的数据copy到内核的sokcet缓冲区中，然后通过DMA将数据copy到网卡
   发出去。
   上面的read,write过程可以看出每次需要把内核空间的数据拷贝到用户空间中，所以O拷贝就是为了解决这个问题的，O拷贝的两种方式：
   1 mmap+write方式
   2 sendfile技术
 2 虚拟内存
  现在操作系统都使用虚拟内存，使用虚拟的地址取代物理地址，好处如下：
  1 一个以上的虚拟地址可以指向同一个物理内存地址
  2 虚拟内存空间可大于实际可用的物理地址
  利用第一条特性可以把内核空间地址和用户空间的虚拟地址映射到同一个物理地址，这样DMA就可以填充对内核和用户空间进程同时可见的缓冲区了，大致如下：
  
  用户空间          |         内核空间
  缓冲区1                     缓冲区2
  【实际物理内存】《可以指定缓冲区1和缓冲区2都映射到同一块物理内存》，这样就省去了内核和用户空间的来回拷贝，
  
  mmap+write方式：
  mmap是一种内存映射文件的方式，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系
  有个这样的机制后：进程可以通过指针方式操作这块内存，系统会自动回写脏页面到对应的磁盘文件中，不用之前那种read,write方式，
  
  用户空间     |      内核空间    |   外存
    缓存----（映射）--->缓存<----DMA---磁盘（从内核空间到用户空间的缓存就省掉了）
                内核socket缓存---DMA-->网卡(目前这一步没有省掉)
                
  sendfile技术：
  目的是简化通过网络在两个通道之间进行的数据传输过程，sendfile系统调用的引入，不仅减少数据复制，减少上下文切换次数，
  用户空间     |      内核空间      |     外部设备
  用户缓存          内核read缓存<---DMA----磁盘
                   内核socket缓存--DMA---->网卡
  数据传输只发生在内核空间，减少一次上下文切换，但是还是存在一次copy，linux2.4做了改进，将buffer中对应的数据记录到相应的socket缓冲区，省去copy了
  
  下面谈一下Java的0拷贝：
  1 MappedByteBuffer:
  java nio提供的FileChannel提供了map()方法，该方法可以在一个打开的文件和MappedByteBuffer之间建立一个虚拟内存映射，MappedByteBuffer继承于
  ByteBuffer,类似于一个基于内存的缓冲区，只不过该对象存储在磁盘的一个文件中，
  2 DirectByteBuffer
  继承于MappedByteBuffer,从名字可以猜测出开辟一段直接内存，并不会占用JVM内存，
  3 Channel-to-Channel传输
  经常需要从一个位置将文件传输到另外一个位置，FileChannel提供了transferTo方法提高传输效率
  
 RocketMQ的消息采用顺序写到commitlog文件，使用mmap方式
 kafka中存在大量网络数据持久化到磁盘，和磁盘文件通过网络发送的过程，通过sendfile技术实现0拷贝。
 
  
                   
3 内存池







