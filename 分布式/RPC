eg: dubbo
核心能力：面向接口的远程方法调用； 智能容错； 负载均衡

服务提供者在启动时，向注册中心注册自己的服务
服务消费者在启动时，会向注册中心订阅自己所需要的服务
注册中心向服务消费者返回服务提供者服务的地址列表，如果有变更基于长连接推送给服务注消费者
服务消费者从服务的地址列表，基于负载均衡算法，选择一个服务提供者进行调用，如果调用失败，再选择另外一台

dubbo支持的通信协议：
dubbo协议：单一长连接，NIO异步通信，基于Hession作为序列化协议，使用场景：数据量小，并发程度高
rmi协议：Java二进制序列化方式，适用于文件传输，较少使用
hession协议：hessian序列化协议，多个短连接，适用于提供者数量比消费者数量还多
http协议：基于json序列化，

netty调用，异步转同步
网络调用过程：
1 服务调用者，封装RequestID,将ID和处理结果的回调对象放到一个全局对象concurrentHashMap
2 将调用信息封装成一个object,通过netty异步发送
3 当前调用线程使用callBack的get方法尝试获取结果，里面就是判断是否有结果，trylock， await，unlock
4 服务端接受请求并处理后，将结果发送给客户端，客户端socket链接监听结果，取ID，从而把对应的callback设置上去。


负载均衡：
一致性hash，
轮询
加权轮询
随机



----透明化远程调用？ 
  使用动态代理
  
----对消息进行编码和解码？

  客户端请求的消息体一般包括以下内容
  接口名称，如果不传服务端不知道调用哪个接口
  方法名，一个接口里有很多方法
  参数类型，参数值
  超时时间
  RequestID
  
  服务端返回的消息体包含以下内容：返回值，返回code,RequestID
  
----序列化
  确定消息体结构后，需要考虑序列化和反序列化，
  why序列化：转化成二进制后才好网络传输
  why反序列化：由二进制转化成对象后才好后续处理
  序列化要求：1 通用性，比如特殊数据结构也能序列化和反序列化 2 性能，时间和空间复杂度 3 可扩展性，支持增加减少字段不影响服务
  比较常用的：pb,thrift
  
  
----网络通信
  序列化后需要把二进制数据进行网络传输，
  两种网络通信模型 ： BIO NIO
  目前业界常用的是netty
  
----发布自己的服务
  自动告知，增加删除机器节点时对调用方透明，调用方不需要写死服务的ip和端口，目前zk被广泛用于服务的注册与发现
  zk可以当做服务注册表，让多个服务提供者形成一个集群，让消费者通过服务注册表获取服务提供者的ip端口等信息。
  具体来说，zk是分布式文件系统，当一个服务部署后将自己的服务注册到zk的某一路径上：/service/version/ip：port
  zk也提供了心跳功能，定时向各个服务提供者发送心跳，如果长期没有响应，服务中心认为服务挂了，将其踢出，服务消费者会监听响应的路径，一旦路径上的数据发送
  变化，zk会通知消费方列表已经改变，从而更新。

  
  
