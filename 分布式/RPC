eg: dubbo
核心能力：面向接口的远程方法调用； 智能容错； 负载均衡

服务提供者在启动时，向注册中心注册自己的服务
服务消费者在启动时，会向注册中心订阅自己所需要的服务
注册中心向服务消费者返回服务提供者服务的地址列表，如果有变更基于长连接推送给服务注消费者
服务消费者从服务的地址列表，基于负载均衡算法，选择一个服务提供者进行调用，如果调用失败，再选择另外一台

dubbo支持的通信协议：
dubbo协议：单一长连接，NIO异步通信，基于Hession作为序列化协议，使用场景：数据量小，并发程度高
rmi协议：Java二进制序列化方式，适用于文件传输，较少使用
hession协议：hessian序列化协议，多个短连接，适用于提供者数量比消费者数量还多
http协议：基于json序列化，

netty调用，异步转同步
网络调用过程：
1 服务调用者，封装RequestID,将ID和处理结果的回调对象放到一个全局对象concurrentHashMap
2 将调用信息封装成一个object,通过netty异步发送
3 当前调用线程使用callBack的get方法尝试获取结果，里面就是判断是否有结果，trylock， await，unlock
4 服务端接受请求并处理后，将结果发送给客户端，客户端socket链接监听结果，取ID，从而把对应的callback设置上去。


负载均衡：
1 轮询算法
  通过AtomicInteger标识索引，++，取余，从而得到对应IP节点
  缺点：1 机器性能发挥不出来， 2 同一个用户的请求分配到不同的机器上
  使用场景：1 只读不写无状态的情况 2 节点的硬件配置一致 
2 随机算法
  
3 平滑加权轮询
   比如 三台机器的权重是1｜2｜3
   首先 初始化（动态权重值=0，权重值=对应权重值），然后动态权重值 = 动态权重值+权重值 （1，2，3）
   然后选取最大的动态权重值最为节点返回，然后对应的动态权重 = 动态权重- sum权重，即 （1，2，-3）
   依次。。。。
   考虑到机器特性做到能者多劳，但是仍然做不到同一个用户请求到同一台机器上的问题  
4 一致性hash
    核心结构是一个hash环，不是对机器个数取模，而是对2^32 进行取模，得到对应的地点，然后顺时针找到的一个则是
    但是有偏移热点的问题，则需要加虚拟节点
   
一致性hash，
轮询
加权轮询
随机



----透明化远程调用？ 
  使用动态代理
  
----对消息进行编码和解码？

  客户端请求的消息体一般包括以下内容
  接口名称，如果不传服务端不知道调用哪个接口
  方法名，一个接口里有很多方法
  参数类型，参数值
  超时时间
  RequestID
  
  服务端返回的消息体包含以下内容：返回值，返回code,RequestID
  
----序列化
  确定消息体结构后，需要考虑序列化和反序列化，
  why序列化：转化成二进制后才好网络传输
  why反序列化：由二进制转化成对象后才好后续处理
  序列化要求：1 通用性，比如特殊数据结构也能序列化和反序列化 2 性能，时间和空间复杂度 3 可扩展性，支持增加减少字段不影响服务
  比较常用的：pb,thrift
  
  
----网络通信
  序列化后需要把二进制数据进行网络传输，
  两种网络通信模型 ： BIO NIO
  目前业界常用的是netty
  
----发布自己的服务
  自动告知，增加删除机器节点时对调用方透明，调用方不需要写死服务的ip和端口，目前zk被广泛用于服务的注册与发现
  zk可以当做服务注册表，让多个服务提供者形成一个集群，让消费者通过服务注册表获取服务提供者的ip端口等信息。
  具体来说，zk是分布式文件系统，当一个服务部署后将自己的服务注册到zk的某一路径上：/service/version/ip：port
  zk也提供了心跳功能，定时向各个服务提供者发送心跳，如果长期没有响应，服务中心认为服务挂了，将其踢出，服务消费者会监听响应的路径，一旦路径上的数据发送
  变化，zk会通知消费方列表已经改变，从而更新。

Q:
 HTTP 和 RPC的区别
 首先两者不是一个概念层面的东西，HTTP是一种通信协议，RPC是一种方法统称，远程过程调用，其次，从两则的效率来看，有些HTTP 层面的协议比较冗余，性能相对来说较差，而某些RPC
 基于TCP协议进行封装效率相对会更高一点，3 适用场景不同，比如你要跟外界进行交互，比如。。。，一般都是选用HTTP，而公司内部服务间由于规范协定，都是选择统一的RPC调用。
  
