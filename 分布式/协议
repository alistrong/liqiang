协议分类
文本协议：
优点：直观，可读性描述性强，容易理解，便于调试扩展性好（eg：json格式）
缺点：冗余数据较多，不适合传输二进制文件

二进制协议：
优点：传输高效，方便解析
缺点：可读性差，难于调试、扩展性不好

eg SCF协议
版本号|协议长度|序列号|服务编号|消息体类型|压缩算法|序列化规则|平台号|消息主题

服务调用过程

调用方                                              服务方
  |                                                   |
  |                                                   |
 代理                                                代理
序列化/反序列化                                   序列化/反序列化
网络模块             <-------------------->        网络模块

tcp粘包拆包问题
假设客户端分别发送两个数据包P1和P2给服务端，由于服务端一次性读到的字节数不确定，所以可能出现下面四种清空：
1 正常情况下，client ------>P1----->P2-------->server,即服务端分两次读取到两个独立的数据包，即P1和P2，没有粘包和拆包
2 client----->P1P2------>server 服务端一次接收到两个数据包,P1和P2粘合在一起，称为TCP粘包
3 client----->P2-tail--->P2headP1------>server 服务端分两次读取到数据包，第一次读到完整的P1和P2的一部分，第二次读到P2的剩余部分。称为TCP拆包
4 client----->P2P1tail--->P1hread------->server 服务端分两次读取到数据包，第一次读取P1的一部分，第二次读取到P1的剩余和P2的全部，称为TCP拆包。
当TCP滑动窗口特别小时，而数据包P1和P2很大时，可能发生第5种情况，服务端多次接受数据包，发生多次拆包

TCP拆包和粘包的原因：
1 滑动窗口
先介绍一下滑动窗口，TCP流量控制一般使用滑动窗口，滑动窗口是接收数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此控制发送端发送数据的大小，从而
达到控制流量的问题。这个窗口大小就是我们一次传输几个数据，发送方在发送过程中保持一个发送窗口大小，只有落到窗口帧里的数据才允许发送，同时接收方维护一个
接收窗口，只有落在接收窗口里的数据才允许接收，这样通过调整发送方和接收方的窗口大小控制流量；
下面看一下滑动窗口是如何导致拆包和粘包的:
粘包情况:当接收方来不及处理数据时，发送的数据都会缓存到接收方的接受缓存区中（SO_RCVBUF）,最后接受缓存区中包含很多报文，对于接收方而言就是粘包
拆包情况：假如接收方的窗口大小只剩100个，意味着发送方最多发送100个数据，而由于发送方的数据大小超过100，会导致拆包，发送前100个数据，等对方ACK后，发
         送剩余数据。
2 MSS和MTU 
  MSS:Maximum Segment Size，表示TCP报文中data部分的最大长度，是TCP协议在IOS五层模型中传输层对一次可以发送数据大小的限制
  MTU:Maximum Transmission Unit 最大传输单元，是OSI五层模型中链路层对一次可以发送数据大小的限制。
  当传输的数据超过MSS或者MTU时，数据将会拆成多个包进行传输，由于MSS是根据MTU计算出来，因此当数据满足MSS时，必然满足MTU.
3 angle算法
  算法背景：TCP/IP协议中，不管data数据发送大小，总是在数据前面加上协议头（IP head协议，TCP head协议），同时接收方收到数据需要发送ack表示确认，
  即时发送数据是1byte，也需要加上40字节TCP头协议，这种情况（1字节有用数据+40头部协议）很消耗网络带宽，浪费，为了尽可能利用网络带宽，TCP总是希望
  尽可能发送足够多的数据（TCP尽可能希望每次以MSS尺寸发送数据），Nagle算法就是为了尽可能发送大块数据，避免网络充斥大量小块数据。
  
  angle算法协议：
  如果发送缓冲区数据大小超过MSS，则允许发送。
  如果发送缓冲区里的数据包含FIN（表示连接请求关闭）则先把发送缓冲区里的数据发送，然后发送关闭连接报文。
  设置了TCP-NODELAY=true,则允许发送，TCP_NODELAY表示取消TCP确认延迟机制，相当于禁止angle算法。
  上述条件都没有满足，但发送超时（200ms）,则立即发送。
  


javaNIO中，客户端不断向服务端发送数据包，服务端收到数据会出现两个数据包粘在一起的情况，即TCP协议中遇见的粘包和拆包问题
client ====pack1====pack2====> server
正常如果接受端收到两个包，就是正常现象没有问题，
client ====pack1tail=====pack1headpack2 ====> server
上面这种情况由于接受端不知道这两个数据包的界限，很难处理，TCP是流协议，没有界限的一串数据。TCP底层并不了解上层业务数据含义，他会根据TCP缓冲区实际情况
进行包的划分，所以在业务上一个完整的包可能被TCP拆分多个包进行发送，也有可能把多个小包封装成一个大的数据包发送。


当发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包
待发送数据大于MSS(最大报文长度),TCP在传输前将进行拆包。
要发送的数据小于TCP发送缓冲区时，TCP将多次写入缓冲区的数据一次性发送出去，将会发送粘包

原因：
1 当连续发送数据时，由于tcp协议的nagle算法，会将较小的内容拼接成大的内容，一次性发送给服务器端，导致粘包
2 当发送内容较大时，由于服务器端的recv方法中的buffer_size较小，不能一次性完全接受全部内容，因此在下一次请求到达时，接受的内容依然是
上次没有完全接收的内容，而造成粘包

只能上层的应用协议栈解决

如何解决：
1 固定长度(限制性强，一般不固定)
2 分隔符（包的头尾加一些特定字符，但是如果包中数据存在跟分隔符相同的二进制，导致分割出问题）
3 协议约定长度（协议的某几位定义包的长度）

Netty的拆包解决方案
服务端在发送数据之前先对数据按照一定规则进行编码，客户端收到数据时按照相同规则进行解码

TCP属于传输层协议，除了TCP还有UDP，UDP是否会发生粘包或拆包的现象吗
不会，UDP基于报文发送，从UDP帧结构中看出，首部采用16bit指示UDP数据报文的长度，因此应用层可以很好区分从而避免粘包和拆包问题。


