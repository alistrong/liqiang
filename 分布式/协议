协议分类
文本协议：
优点：直观，可读性描述性强，容易理解，便于调试扩展性好（eg：json格式）
缺点：冗余数据较多，不适合传输二进制文件

二进制协议：
优点：传输高效，方便解析
缺点：可读性差，难于调试、扩展性不好

eg SCF协议
版本号|协议长度|序列号|服务编号|消息体类型|压缩算法|序列化规则|平台号|消息主题

服务调用过程

调用方                                              服务方
  |                                                   |
  |                                                   |
 代理                                                代理
序列化/反序列化                                   序列化/反序列化
网络模块             <-------------------->        网络模块

tcp粘包问题
javaNIO中，客户端不断向服务端发送数据包，服务端收到数据会出现两个数据包粘在一起的情况，即TCP协议中遇见的粘包和拆包问题
client ====pack1====pack2====> server
正常如果接受端收到两个包，就是正常现象没有问题，
client ====pack1tail=====pack1headpack2 ====> server
上面这种情况由于接受端不知道这两个数据包的界限，很难处理，TCP是流协议，没有界限的一串数据。TCP底层并不了解上层业务数据含义，他会根据TCP缓冲区实际情况
进行包的划分，所以在业务上一个完整的包可能被TCP拆分多个包进行发送，也有可能把多个小包封装成一个大的数据包发送。
当发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包
待发送数据大于MSS(最大报文长度),TCP在传输前将进行拆包。
要发送的数据小于TCP发送缓冲区时，TCP将多次写入缓冲区的数据一次性发送出去，将会发送粘包

原因：
1 当连续发送数据时，由于tcp协议的nagle算法，会将较小的内容拼接成大的内容，一次性发送给服务器端，导致粘包
2 当发送内容较大时，由于服务器端的recv方法中的buffer_size较小，不能一次性完全接受全部内容，因此在下一次请求到达时，接受的内容依然是
上次没有完全接收的内容，而造成粘包

只能上层的应用协议栈解决

如何解决：
1 固定长度(限制性强，一般不固定)
2 分隔符（包的头尾加一些特定字符，但是如果包中数据存在跟分隔符相同的二进制，导致分割出问题）
3 协议约定长度（协议的某几位定义包的长度）

Netty的拆包解决方案
服务端在发送数据之前先对数据按照一定规则进行编码，客户端收到数据时按照相同规则进行解码

TCP属于传输层协议，除了TCP还有UDP，UDP是否会发生粘包或拆包的现象吗
不会，UDP基于报文发送，从UDP帧结构中看出，首部采用16bit指示UDP数据报文的长度，因此应用层可以很好区分从而避免粘包和拆包问题。


