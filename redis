关于redis介绍
redis 是key/value的内存存储系统，整个数据库加载到内存中进行操作，再定期通过异步操作将数据flush到硬盘进行保存。

value的数据类型可以是String,set,list,hash,sorted set
1 String
内部存储默认就是字符串，被redisObject所引用，遇到incr,decr操作时，转成数值进行计算，此时redisObject的encoding是int
底层实现有三种：int,raw,embstr. int编码和embstr编码在一定条件下会转化成raw编码对象
int: 8个字节的长整形
embstr：<=39个字节的字符串
raw: >39个字节的字符串，长度动态可变，char buf[];int len;int free; 

2 Hash
redis的hash实际内存存储的Value为一个HashMap,并提供了直接存取这个Map成员的接口
这个HashMap有两种实现方式，成员较少时，为了省内存采用一维数组紧凑存储，此时redisObject的encoding是ziplist
                         当成员多时，转成真正的hashMap,此时encoding是ht
  
3 List
应用场景非常多，eg 关注列表，粉丝列表
实现方式是双向链表，即可以支持反向查找和遍历,当数据较少时，实现结构是压缩列表

4 Set
实现方式是一个value永远是null的HashMap,实际就是通过计算hash的方式来快速排重的
如果一个集合只含有整数且元素不多时使用intset（整数集合）作为底层实现

5 Sorted Set
有序（score）并且不重复的集合列表
内部使用HashMap和跳跃表（SkipList）来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表存放所有的成员
成员较少时，用ziplist。




为什么使用redis：
因为性能和并发，支持数据类型丰富

单线程的redis为什么很快：
纯内存操作，
单线程避免上下文频繁切换，
多路复用I/O模型，

redis过期策略和内存淘汰机制：
定期删除+惰性删除：redis默认每隔100ms定时检测是否有过期的key，有过期的key则删除，但不是对所有的key都进行检测，而是随机抽取
进行检查，这样会导致大量的过期的key并没有被删除，因此有另外一个策略惰性删除，在取key时会检测这个key是否过期，过期就删除。只有这两个策略还是有问题，当没有
去取key时，内存中会有大量的过期的key，因此内存淘汰机制出现了，当需要新写入数据时，发现空间不够，LRU


缓存和数据库数据一致性问题：
首先唯一确定是删除缓存而不是更新缓存，因为lazy加载的模式，因为有时候更新操作涉及好多表，但是又没有读请求，一直更新缓存没啥意义。
对于双写数据库和缓存 删除缓存，后更新数据库这种机制也可能出现脏数据情况（删完后，来了读请求，从而构建了老的缓存，后来才更新成功）
解决方案：当写操作作为唯一标识放入内存队列中，当有读操作时，判断队列中有没有写操作，如果有，先放入队列中，

redis穿透问题：
频繁查询一个不存在的数据，由于缓存没有命中，从而查数据层，缓存失去意义，解决方法：加一层布隆过滤器，过滤掉不存在的key，缓存加空值并设置TTL

redis雪崩问题：
缓存大量失效，导致读取数据库请求大量增加
1 key的过期时间+随机值，防止大量key同一时刻失效
2 互斥锁，分布式锁

并发竞争key问题：
大量同时去set 同一个key
不要求顺序：分布式锁方式，抢到锁进行set操作，
要求顺序：写入数据库的时候，增加一个时间戳字段，
         利用队列，将set方法变成串行访问


