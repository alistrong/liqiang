关于redis介绍
redis 是key/value的内存存储系统，整个数据库加载到内存中进行操作，再定期通过异步操作将数据flush到硬盘进行保存。

value的数据类型可以是String,set,list,hash,sorted set
1 String
内部存储默认就是字符串，被redisObject所引用，遇到incr,decr操作时，转成数值进行计算，此时redisObject的encoding是int
底层实现有三种：int,raw,embstr. int编码和embstr编码在一定条件下会转化成raw编码对象
int: 8个字节的长整形
embstr：<=39个字节的字符串
raw: >39个字节的字符串，长度动态可变，char buf[];int len;int free; 

2 Hash
redis的hash实际内存存储的Value为一个HashMap,并提供了直接存取这个Map成员的接口
这个HashMap有两种实现方式，成员较少时，为了省内存采用一维数组紧凑存储，此时redisObject的encoding是ziplist
                         当成员多时，转成真正的hashMap,此时encoding是ht
  
3 List
应用场景非常多，eg 关注列表，粉丝列表
实现方式是双向链表，即可以支持反向查找和遍历,当数据较少时，实现结构是压缩列表

4 Set
实现方式是一个value永远是null的HashMap,实际就是通过计算hash的方式来快速排重的
如果一个集合只含有整数且元素不多时使用intset（整数集合）作为底层实现

5 Sorted Set
有序（score）并且不重复的集合列表
内部使用HashMap和跳跃表（SkipList）来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表存放所有的成员
成员较少时，用ziplist。




为什么使用redis：因为性能和并发，支持数据类型丰富

单线程的redis为什么很快：内存模型，单线程避免上下文频繁切换，多路复用I/O模型，
redis过期策略和内存淘汰机制：定期删除+惰性删除：redis默认每隔100ms定时检测是否有过期的key，有过期的key则删除，但不是对所有的key都进行检测，而是随机抽取
进行检查，这样会导致大量的过期的key并没有被删除，因此有另外一个策略惰性删除，在取key时会检测这个key是否过期，过期就删除。只有这两个策略还是有问题，当没有
去取key时，内存中会有大量的过期的key，因此内存淘汰机制出现了，当需要新写入数据时，发现空间不够，LRU
缓存和数据库数据一致性问题：对于双写数据库和缓存应该先更新数据库，然后删除缓存。
redis穿透问题：频繁查询一个不存在的数据，由于缓存没有命中，从而查数据层，缓存失去意义，解决方法：加一层布隆过滤器，过滤掉不存在的key，缓存加空值并设置TTL
redis雪崩问题：缓存大量失效，导致读取数据库请求大量增加，
