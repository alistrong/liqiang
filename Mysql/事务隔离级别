
1 读未提交
最低的隔离级别，一个事务可以读到另一个事务未提交的数据，这种现象称为脏读

数据库实现原理：事务在读的时候不加锁，在更新的时候只加行级共享锁

事务1在读取数据时，事务2也可以读取和修改数据（因为事务1没有加任何锁）
当事务2更新数据时，事务1可以读取最新的数据，因为事务2更新时加的是共享锁，事务1读取数据时，可以加共享锁读到数据
当事务1更新数据时，事务2如果想更新该数据需要等待，因为更新数据需要加排他锁

2 读已提交
一个事务在修改数据时，如果没有提交，其他事务是不能读到提交结果的

数据库实现原理：事务读取数据时，加行级共享锁，读完立马释放锁，当事务修改数据时，必须加行级排他锁，执行完才释放锁

事务1在读取某行数据的过程中，事务2也可以读取数据，（因为两个事务读取事务加的是行级共享锁，不冲突）
事务1在读取某行数据时，事务2不能修改该数据，当事务1读完数据，事务2就可以加排他锁进行修改。
事务1在修改数据时，事务2不能修改该数据，等待。因此可以解决脏读问题

读提交保证了读到的数据都是提交的数据，避免了脏读，但是不保证数据更新读是读到同样的数据，因此在每次读完之后，其他事务都可以修改该数据。

//innodb实现读提交原理：
# 读就是快照度
# 对于修改操作加行级锁

3 可重复读

实现原理：事务在读取数据的瞬间，必选先加行级共享锁，直到事务结束之后才释放
         事务在修改数据时，必须加行级排它锁，直到事务结束之后才释放
         
现象： 事务1在读取数据时，事务2也可以读取相同数据，加共享锁，不冲突
      事务1在读取数据时，事务2不能修改相应的数据，因此可以解决不可重复读的问题
      事务1在修改数据时，事务2不能修改不相应的数据。
      
//innodb实现可重复读原理：
# 读就是快照读
# 对于写操作就是加间隙锁（行锁+临键锁）

幻读现象:

事务1 select * from A where age >=10 and age<=30 （假如有十条满足记录）（十条记录加共享锁，其他事务无法修改这十条记录）

事务2 insert into A values (27); （没有任何事务对表增加表级锁，因此可以执行）

事务1 select * from A where age>=10 and age <=30 (现在出来11条记录)

4 可序列化

上述的幻读由于事务1在进行范围查询时没有增加范围锁







