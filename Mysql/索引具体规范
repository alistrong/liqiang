eg employees表中 建立联合索引（A,B,C）

1 select * from employees where A = 'a' and B = 'b' and C = 'c';
相当于全列匹配，所有列进行精准匹配，索引可以被用到，mysql查询优化器会自动调整where子句的条件顺序以使用适合的索引 。
即where B = 'b' and C = 'c' and A = 'a' 也可以用到索引

2 select * from employees where A = 'a';
相当于最左前缀匹配原则，当查询条件精准匹配索引的左边连续一个或者几个列时，索引可以被使用到，但是只能用到一部分，即条件组成的最左前缀
eg select * from employees where A = 'a' and C = 'c'，由于B条件没有，查询只用到索引的第一列，

3 范围查询
select * from employees.B where A >'ds' and B ='342';
范围列A可以使用到索引（最左匹配）,但是范围列B后面的列无法使用到索引，同时索引最多用于一个范围列，因此如果查询条件有两个范围列则无法全用到索引

 select * from employees.B where A between '100001' and  '100010' and B = '234' and C between 'aa' and 'vv';
 上面语句看起来是用了两个范围查询，但是作用于A上的Between 实际上相当于IN，也就是说 A属性相当于多值精准匹配，这个查询用到了索引的三个列

尽量在INNODB上采用自增字段做主键，由于InnoBb的索引实现，使用聚集索引，数据记录本身被存于主索引的叶子节点上，这就要求同一个叶子节点的各条记录按主键顺序
存放，因此每当有一条新的记录插入时，MYSQL会根据其主键将其插入适当的节点和位置。
如果使用自增主键，每次插入记录，记录会顺序添加到当前索引节点的后缀位置，当一页写满，就会自动开辟新的页，这样就会形成紧凑的索引结构，近似顺序填满，不需
移动已有数据，
如果使用非自增主键，每次插入近似随机，因此每次新记录都要被插到现有索引页的中间某位置，不得不移动数据。

