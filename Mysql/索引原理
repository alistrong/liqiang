 背景：流水未分库分表的大表，数据量950w,分页查询使用limit语句
 select a,b,c from table where 条件 limit 0,10;
 
 优化后语句：
 select a,b,c from main_table right join (select 主键 from table where 条件 limit 0,10) temp_table on temp_table.a = main_table.a;
 
 我们知道limit offset rows，当offset很大时，效率很低，
 我们先看一下select * from table where 条件 limit 300000,10 的查询过程;
 
 查询索引叶子节点数据，然后根据叶子节点的主键值去聚簇索引上查询需要的所有字段值。
 查询300010次索引节点，然后300010次聚簇索引的数据，然后将结果过滤掉前300000个，最后取出最后10条记录，即mysql耗费了大量随机I/O在查询聚簇索引的数据上。
 即由300000次聚簇索引查询是无用的。
 
 我们设想为啥不直接先根据二级索引过滤掉只剩10条主键索引，然后根据聚簇索引找到最终10条的数据集呢？
 如果select * 中的* 只是包含主键，则mysql会先执行offset偏移操作，根据后面的主键索引读取最终的数据块。
 对于需要查询所有字段的情况，二级索引可以找到主键值，但还需要根据聚簇索引读数据块获得其他字段，因此mysql会先读取数据块内容，然后执行offset偏移操作。
 
 有实验证实上述情况：
 mysql 有buffer pool,存放最近访问的数据页，执行前后两个sql语句，观察buffer pool里面的数据，发现优化后的pool内容较少。
 
 整体优化思路：先找出偏移后的主键，然后根据主键索引查找数据块。


局部性原理：直接读一页的数据。
INNODB页的结构：一页16kb

  pre--[页头]--next
页目录       用户数据区域
目录1         第一行数据
目录2         第二行数据
目录3         第三行数据
 
       联合索引（b,c,d）
        B+数据结构
               b,c,d
     b1,c1,d1           b2,c2,d2
(主键值)a4                 a3
//最左匹配原则：where c = 2 and d = 3; 肯定不走辅助索引
               where b>2 ; //不走索引，需要回表，可能选择全表扫描，如果是select b的话，走索引了。



为啥选择B+树作为索引数据结构

B+Tree特点： 1 与B树相比，非叶子结点只存储关键字，具体的数据存放在叶子结点上
            2 叶子结点之间有链指针
            
为什么没有使用跳表skiplist?

两者最下面一层都包含了所有的数据且都是顺序的，方便范围查询，往上层的索引结构都是为了提升搜索性能，但是在新增和删除数据方便还是有区别

B树是多叉树，每个节点有16kb的大小，一页能存放较多的索引信息，扇出很高，3层差不多存2000w记录，基本上3次IO就可以
而跳表如果想要得到二分查找的效果，对于2kw记录，基本上需要24层高度，最坏的情况，需要经过24次磁盘IO
对于存放同样量级的数据，显然B+高度比跳表低很多，磁盘IO次数更少，B+树查询更快
而对于写入操作，B+需要拆分合并数据页，而跳表独立插入，没有所谓的旋转维持平衡的开销，因此跳表的写入性能会更好，


redis为什么使用跳表呢？
我们知道redis是内存数据库，读写数据都是基于内存操作，没有磁盘的问题，层高就不再是所谓的差点，插入数据不考虑平衡旋转的问题，因此性能更好



