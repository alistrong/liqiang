大类上JUC分为以下几种：

1 并发容器：ArrayBlockingQueue,ListedBlockingQueue,.....
2 同步设备：
3 锁:
4 原子对象：
5 线程池：

并发容器详解:

class ArrayBlockingQueue<E> extends AbstractQueue implements BlockingQueue<E>{
    final Object[] items;
    int takeIndex;
    int putIndex;
    int count;
    final ReentrantLock lock;
    private final Condition notEmpty;
    private final Condition notFull;
    public ArrayBlockingQueue(int capacity,boolean fair){
        this.items = new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull = lock.newCondition();
    }
    public boolean offer(E e){
        checkNotNull(e);
        finalReentrantLock = this.lock;
        lock.lock();
        try{
            if(count == item.length) return false;
            else enqueue(e); return true;// enqueu() 里往队列里加数据,索引位置变化，count++; notEmpty.signal();
        }finally{
            lock.unlock();
        }
    }
    public E poll(){
        final ReentrantLock lock = this.lock;
        lock.lock();
        try{
            return (count==0)?null:dequeue();//获取数据，索引变化，count--，notFull.signal();
        }finally{
            lock.unlock();
        }
    }
    
    class LinkedBlockingQueue {
        static class Node<E>{ E item; Node<E> next; Node(E x){item = x;}}
        private final int capacity;//容量
        private final AtomicInteger count = new AtomicInteger();//当前个数
        transient Node<E> head;
        private transient Node<E> last;
        private final ReentrantLock takeLock = new ReentrantLock();
        private final ReentrantLock putLock = new ReentrantLock();
        private final Condition notEmpty = takeLock.newCondition();
        private final Condition notFull = putLock.newCondition();
    }
    
    对比：LinkedBlockingQueue 支持两个锁，put和taken两个锁，某些操作单独加各自的锁，不冲突，加速吞吐量；利用AtomicInteger保证两个锁变化数据可见；
         一个链表，一个数组，初始化时Linked有默认MAX,Array必须传入一个值
         
    
    
    
同步设备：
    CountDownLatch: 并发工具类，允许一个线程或多个线程等其他线程操作执行完后再执行
    class CountDownLatch{
        private final Sync sync;
        public CountDownLatch(int count){this.sync = new Sync(count);}
        public void await()throws InterruptedException{sync.acquireSharedInterruptibly(1);}
        public void countDown(){sync.releaseShared(1)}
        public long getCount(){return sync.getCount();}
    }
    核心是Sync implements AQS{
        Sync(int n){setState(n);}
        int getCount(){return getState();}
        tryAcquireShared(int acquires){return (getState()==0? 1:-1);}
        tryReleaseShared(int releases){}
        ......
    }
    下面详细讲解AQS
    AQS主要包括一个int类型的state共享变量来表示同步状态和一个FIFO组成的等待队列，同步状态的释放和获取需要同步器自己去定义具体逻辑，而状态的改变和
    阻塞和等待的机制由AQS自己已经定义实现，对同步组件来说不关系。
    
    共享资源volatile int state {三种方式访问，setState(),getState(),compareAndSetState()},线程等待队列（多线程争用资源阻塞会进入此队列）FIFO
    两种共享方式：同时实现独占和共享两种方式，如ReentrantReadWriteLock
    1 Exclusive (独占，只有一个线程能执行，ReentranLock)
    2 Share(共享，多个线程可同时执行，eg Semaphore CountDownLatch)
    不同的共享器需要自己去实现那个获取state和释放state方法，即以下方法
    tryAcquire();tryAcquireShared();tryRelease();tryReleaseShared()
    其他的(等待通知机制)队列维护AQS已经做好了
    
    Condition详解：
    内部维护等待队列，所有调用condition.wait()都会进去等待队列中，同时释放lock,
    
    CyclicBarrier:回环栅栏 让一组线程等待到达某种状态之后再开始全部执行
    
    Semaphore：信号量，控制同时访问的线程个数，与锁有点类似，控制共享资源的访问权限
    class Semaphore{
        public Semaphore(int permits)//默认非公平方式， public Semaphore(int permits,boolean fair);
        private final Sync sync;
        void acquire();//获取前线程一直阻塞
        void release();//释放信号量
    }
    
锁：
    1 ReentrantLock
    Class ReentrantLock{
        private final Sync sync;
        public ReentrantLock(){sync = NonfairSync()} public ReentrantLock(boolean fair){sync = fair? new FairSync() : new NonFairSync()}
        public void lock(){sync.lock();}
        public boolean tryLock(){return sync.nonfairTryAcquire(1);}
        public void unlock(){sync.release(1);}
        public Condition newCondition(){return sync.newCondition();}
    }
    首先介绍写锁的实现：
    同一时刻写锁不能被多个线程获取到，很显然写锁是独占式锁，写锁的同步语义是通过重新tryAcquire，tryrelease方法来实现,读锁通过tryReleaseShared()
    // 可重入的独占锁，同步通过实现AQS，锁的竞争依靠CAS和Unsafe

    2 ReentrantReadWriteLock
    Class ReentrantReadWriteLock{
        private final ReentrantRederWriteLock.ReadLock readerLock;
        private final ReentrantRederWriteLock.WriteLock writeLock;
        final Sync sync;
    }

原子类操作：
    工具类 AtomicInteger
    class AtomicInteger{
        private static final Unsafe unsafe = Unsafe.getUnsafe();
        private static final long valueOffset;
        private volatile int value;
        public final int addAndGet(int n){}//以原子方式将输入的值与实例中原值相加，并返回最新的值
        public final int incrementAndGet() //以原子方式将实例中的值进行加1操作，并返回最新的值
        public final int getAndSet(int n)//将实例中的值更新为输入的值，并返回之前的值
        public final int getAndIncrement(){return unsafe.getAndAddInt(this, valueOffset, 1);}//以原子方式将实例中的值进行加1，并返回以前的值
        //原子类的操作主要依靠Unsafe类的compareAndSwapInt()类似的接口来保证
    }
    工具类 AtomicIntegerArray //原子更新数组类型，在之前的基础上，加上index字段来确定更新的位置
    工具类 AtomicReference //
    
    
}
