1 定位CPU高的原因：
   首先：根据输入top命令后 再输入P， 查看cpu消耗高的pid。 
   然后：根据命令 top -P -a pid 查看这个pid下面消耗CPU最大的线程 tid  (printf '%x\n' tid 得到tid对应的十六进制)
   最后：jstack pid|grep tid(十六进制)            jstack(查看当前所有线程的运行情况和线程当前状态)
   
   jstack 文件：   1   死循环 
                  2   wait()  Thread.State: WAITING
                  3   死锁    deadlock
                  4   等待IO  
2 定位堆溢出问题：
   首先：利用jstat -gcutil pid 查看堆内存使用情况.
   然后：jmap dump:format=b,file =[文件输出路径][pid] 得到dump出来的文件              jmap(监视进程运行中的jvm物理内存的占用情况)
   最后：利用分析工具，如MAT

3 OOM outofmemory
  某个Java服务 出现了OOM，最常见的原因：
  1 内存分配确实过小
  2 某个对象频繁申请，但是没释放，内存泄露导致内存耗尽
  3 某个资源频繁申请，系统资源耗尽，如：不断创建线程，不断发起网络请求
  
  -- jmap -heap pid // 可查看新生代，老年代堆内存的分配大小及使用情况，看是否本身分配过小
  -- 找最耗内存的对象 jmap -histo:live pid |more  会展示 按照内存大小排序的存活对象信息（实例数|所占内存大小|类名）
     如果发现某个类对象占用内存很大，很可能类对象创建太多，且一直未释放
  -- 确认是否资源耗尽
     pstree 
     netstat
     查看进程创建的线程数，网络连接数，如果资源耗尽有可能出现OOM
     
  
  
  
