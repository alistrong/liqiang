动态规划

“记住你之前做过的事”，当之前的问题和当前的问题有关联性，即之前的答案可以帮助解决当前答案，又有之前问题的答案，

一般解决动态规划问题分为4歩
1 问题拆解，找到问题之间的具体联系
2 状态定义
3 递推方程推导
4 实现

举例
[爬楼梯] 每次可以爬1或2个台阶，你有多少种不同方法爬到楼顶

问题拆解： 到达N个楼梯可以从第n-1个楼梯到和第n-2个楼梯到，因此第n个问题可以拆解成第n-1个问题和第n-2个问题，同时可以继续往下拆，直到第0个问题
状态定义： 我们可以把第i个状态定义为“从起点到达第i个楼梯的路径总数”
递推方程： 第i个状态可以由第i-1个状态和i-2个状态相加得到，即dp[i] = dp[i-1]+dp[i-2];
--------------------------------------------------------------------------------------------
[最大子数组] 给定一个整数数组nums，找到一个具有最大和的连续子数组，返回其最大和

问题拆解：问题的核心是子数组，子数组可以看作一段区间，我们确定一个子数组的截止元素在i这个位置，这时候我们的问题转化成以i为结尾的最大子数组和。
         从而问题拆解为 i这个位置的元素自成一个子数组； i位置的元素值+ 以i-1为结尾的所有子数组中子数组和最大的值
         
状态定义：dp[i]表示以i结尾的所有子数组的最大值

递推方程：dp[i] = Math.max(dp[i-1]+array[i],array[i])

实现：要求子数组不为空，因此一开始需要初始化，也就是dp[0] = array[0]

---------------------------------------------------------------------------------------------

