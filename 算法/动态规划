动态规划

“记住你之前做过的事”，当之前的问题和当前的问题有关联性，即之前的答案可以帮助解决当前答案，又有之前问题的答案，

一般解决动态规划问题分为4歩
1 问题拆解，找到问题之间的具体联系
2 状态定义
3 递推方程推导
4 实现

举例
[爬楼梯] 每次可以爬1或2个台阶，你有多少种不同方法爬到楼顶

问题拆解： 到达N个楼梯可以从第n-1个楼梯到和第n-2个楼梯到，因此第n个问题可以拆解成第n-1个问题和第n-2个问题，同时可以继续往下拆，直到第0个问题
状态定义： 我们可以把第i个状态定义为“从起点到达第i个楼梯的路径总数”
递推方程： 第i个状态可以由第i-1个状态和i-2个状态相加得到，即dp[i] = dp[i-1]+dp[i-2];
--------------------------------------------------------------------------------------------
[最大子数组] 给定一个整数数组nums，找到一个具有最大和的连续子数组，返回其最大和

问题拆解：问题的核心是子数组，子数组可以看作一段区间，我们确定一个子数组的截止元素在i这个位置，这时候我们的问题转化成以i为结尾的最大子数组和。
         从而问题拆解为 i这个位置的元素自成一个子数组； i位置的元素值+ 以i-1为结尾的所有子数组中子数组和最大的值
         
状态定义：dp[i]表示以i结尾的所有子数组的最大值

递推方程：dp[i] = Math.max(dp[i-1]+array[i],array[i])

实现：要求子数组不为空，因此一开始需要初始化，也就是dp[0] = array[0]

---------------------------------------------------------------------------------------------

[最小路径和] 给定一个包含非负整数 m*n网格，请找出一条从左上角到右下角的路径，使得路径上的数字和为最小
说明：每次只能向下或者向右移动
问题拆解：当前的问题可以拆分为两个子问题（上面的位置或者左边的位置）
状态定义：dp[i][j]表示 以<i,j>位置的最小路径和
递推方程：dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]

----------------------------------------------------------------------------------------------
上面分析了矩阵类的动态规划，只需要考虑当前位置的信息即可，分析并定义状态的时候，也只需要分析当前位置与其相邻位置的关系。
下面我们看一下序列类动态规划问题，通常涉及问题的输入参数是数组或者字符串
子序列相对于子数组来说，子数组是连续的区间，子序列并没有这个要求，因此对于序列类的动态规划在于，对于第i个位置的状态分析，它不仅仅需要考虑当前位置的状态
还要考虑前面i-1个位置的状态，即通常思考的方向是寻找当前状态和之前所有状态的关系。
[最长上升子序列] 给定一个无序数组，找到其中最长上升子序列的长度
问题拆解：如果我们确定终点，就需要看前面i-1个位置中，那个位置可以和当前位置拼接在一起，这样就可以把第i个位置拆解成思考之前i-1个问题，
状态定义：dp[i]表示以i位置为结尾的最长上升子序列长度
递推方程:dp[i]= max(num[j])+1 { num[i]<num[j]}

------------------------------------------------------------------------------------------------
[股票买卖]只能买卖一次，求最大利润










