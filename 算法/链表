链表和数组是数据结构的基础，而链表是物理存储单元上非连续的、非顺序的存储结构，它由一个个结点，通过指针来联系起来的，包括数据和指针。
相对于数组，在局部性原理的基础上，性能不如数组，由于结点的地址不相邻，但是在以下场景考虑使用链表:
1 大内存空间分配，由于数组空间的连续性，如果要为数组分配500M的空间，这500M的空间必须是连续、未使用的。因此在内存分配上数组相对比较严格，如果碎片太多，
分配连续的空间很有可能失败，
2 元素频繁的插入和删除，
如果查询为主，很少涉及增删，推荐数组
如果涉及比较频繁增删，或者所需分配空间较大，倾向于选择链表





1 给定单链表头指针和节点指针，O（1）删除该节点

通过当前节点找到后面的节点，然后把后面节点的值赋给当前节点，然后删除后面的节点。
如果指定节点是尾节点，还是需要通过遍历找到节点的前一个节点，赋值为null。

2 链表反转

递归方法：
public Node invert(Node head){
    if(head.next == null){
        return head;
    }
    Node newHead = invert(head.next);    
    head.next.next = head;
    head.next = null;
    return newHead;
}

非递归方法：
Node pre = head.next;
Node cur = pre.next;
while(cur!=null){
   Node next= cur.next;
   cur.next = pre;
   pre = cur;
   cur = next;
}
head.next = pre;

3 寻找第K个节点

快慢指针：快慢指针同时指向head的后继节点；然后快指针先走K-1歩，指到第K个节点；然后快慢指针同时走，直到快指针走到尾部，此时slow指针就是我们要找的。

4 判断两链表是否相交及相交的第一个节点。要求空间复杂度O（1）

 先求出两个链表的长度L1和L2,然P1指针先走L1-L2歩，然后两个指针不断向后遍历，然后每走一步，判断是否相等，相等即为结果。
 
5 判断是否有环及入环的节点。


